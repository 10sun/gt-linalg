






<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="initial-scale=1, maximum-scale=1">
  <title>Span of vectors in space</title>

      <link rel="stylesheet" href="mathbox/mathbox.css">
      <link rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css">
  

  <style>
      
  .overlay-popup h2 {
      color:      green;
      text-align: center;
  }
  #span-type {
      border: solid 1px white;
      padding: 5px;
      margin: 5px;
  }
  #inter-is {
      padding: 10px;
  }
  .dg.main .cr.boolean > div > .property-name {
      width: 60%;
  }
  .dg.main .cr.boolean > div > .c {
      width: 40%;
  }
  .dg.main .cr.number.has-slider > div > .property-name {
      width: 10%;
  }
  .dg.main .cr.number.has-slider > div > .c {
      width: 90%;
  }
  .dg.main .cr.number.has-slider > div > .c .slider {
      width: 85%;
  }
  .dg.main .cr.number.has-slider > div > .c input {
      width: 10%;
  }

  </style>

  <link rel="stylesheet" href="css/demo.css">

</head>
<body>
    

        <script src="mathbox/mathbox-bundle.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.js">
        </script>
        <script src="lib/domready.js"></script>
        <script src="js/demo2.js"></script>
        <script src="lib/dat.gui.min.js"></script>
        <script src="lib/screenfull.min.js"></script>

    

    <script type="text/javascript">
        "use strict";
        DomReady.ready(function() {

        // Generated by CoffeeScript 1.10.0
window.demo = new Demo({
  mathbox: {
    mathbox: {
      warmup: 10,
      splash: false,
      inspect: false
    }
  }
}, function() {
  var base, base1, base2, base3, base4, base5, c, checkLabel, clipCube, coeff, diff, eqnElt, gui, guiElts, j, k, lColors, lLabels, lVectors, len, len1, linCombo, makeTexVecs, onDrag, params, popup, range, ref, ref1, ref2, ref3, ref4, self, snap, snapThreshold, snapped, spanElt, ss0, ss1, ss2, ss3, subspace, subspaces, successElt, surfaceColor, updateCaption, vectorsElt, view, zeroThreshold;
  window.mathbox = this.mathbox;
  this.numVecs = 3;
  this.vector1 = [5, 3, -2];
  this.vector2 = [3, -4, 1];
  this.vector3 = [-1, 1, 7];
  this.labels = ['v1', 'v2', 'v3'];
  this.coeffs = ['x', 'y', 'z'];
  this.lcstart = [1.0, 1.0, 1.0];
  this.colors = [[1, 0.3, 1, 1], [0, 1, 0, 1], [1, 1, 0, 1]];
  this.doTarget = false;
  this.target = null;
  this.targetColor = [1, 1, 1, 1];
  if (this.urlParams.v1 != null) {
    this.numVecs = 1;
    this.vector1 = this.urlParams.v1.split(",").map(parseFloat);
  }
  if (this.urlParams.v2 != null) {
    this.numVecs = 2;
    this.vector2 = this.urlParams.v2.split(",").map(parseFloat);
  }
  if (this.urlParams.v3 != null) {
    this.numVecs = 3;
    this.vector3 = this.urlParams.v3.split(",").map(parseFloat);
  }
  if (this.urlParams.labels != null) {
    this.labels = this.urlParams.labels.split(",");
  }
  if (this.urlParams.coeffs != null) {
    this.coeffs = this.urlParams.coeffs.split(",");
  }
  if (this.urlParams.lcstart != null) {
    this.lcstart = this.urlParams.lcstart.split(",").map(parseFloat);
  }
  if (this.urlParams.target != null) {
    this.target = this.urlParams.target.split(",").map(parseFloat);
    this.doTarget = true;
    if ((base = this.urlParams).lincombo == null) {
      base.lincombo = 'on';
    }
    if ((base1 = this.urlParams).captions == null) {
      base1.captions = 'target';
    }
    if ((base2 = this.urlParams).nomove == null) {
      base2.nomove = 'true';
    }
    if ((base3 = this.urlParams).grid == null) {
      base3.grid = 'on';
    }
  } else if (this.urlParams.captions === 'combo') {
    if ((base4 = this.urlParams).lincombo == null) {
      base4.lincombo = 'on';
    }
    if ((base5 = this.urlParams).grid == null) {
      base5.grid = 'on';
    }
  }
  this.targetLabel = (ref = this.urlParams.tlabel) != null ? ref : 'w';
  this.vectors = [this.vector1, this.vector2, this.vector3].slice(0, this.numVecs);
  this.colors = this.colors.slice(0, this.numVecs);
  this.labels = this.labels.slice(0, this.numVecs);
  this.coeffs = this.coeffs.slice(0, this.numVecs);
  this.lcstart = this.lcstart.slice(0, this.numVecs);
  this.hexColors = (function() {
    var j, len, ref1, results;
    ref1 = this.colors;
    results = [];
    for (j = 0, len = ref1.length; j < len; j++) {
      c = ref1[j];
      results.push("#" + new THREE.Color(c[0], c[1], c[2]).getHexString());
    }
    return results;
  }).call(this);
  this.targetHexColor = "#" + new THREE.Color(this.targetColor[0], this.targetColor[1], this.targetColor[2]).getHexString();
  this.isLive = (this.urlParams.nomove == null) || this.urlParams.nomove === "false";
  params = {
    Axes: this.urlParams.axes === "on"
  };
  checkLabel = "Show " + this.coeffs[0] + "." + this.labels[0];
  if (this.numVecs >= 2) {
    checkLabel += " + " + this.coeffs[1] + "." + this.labels[1];
  }
  if (this.numVecs >= 3) {
    checkLabel += " + " + this.coeffs[2] + "." + this.labels[2];
  }
  params[checkLabel] = this.urlParams.lincombo === "on";
  gui = new dat.GUI({
    width: 350
  });
  guiElts = {};
  if (this.urlParams.axes !== "disabled") {
    guiElts.Axes = gui.add(params, 'Axes');
    guiElts.Axes.onFinishChange(function(val) {
      return mathbox.select(".view-axes").set("visible", val);
    });
  }
  if (this.urlParams.lincombo !== "disabled") {
    guiElts[checkLabel] = gui.add(params, checkLabel);
    guiElts[checkLabel].onFinishChange(function(val) {
      return mathbox.select(".lincombo").set("visible", val);
    });
    params[this.coeffs[0]] = this.lcstart[0];
    guiElts[this.coeffs[0]] = gui.add(params, this.coeffs[0], -10, 10).step(0.1);
    if (this.numVecs >= 2) {
      params[this.coeffs[1]] = this.lcstart[1];
      guiElts[this.coeffs[1]] = gui.add(params, this.coeffs[1], -10, 10).step(0.1);
    }
    if (this.numVecs >= 3) {
      params[this.coeffs[2]] = this.lcstart[2];
      guiElts[this.coeffs[2]] = gui.add(params, this.coeffs[2], -10, 10).step(0.1);
    }
  }
  if ((ref1 = this.urlParams.grid) === "enabled" || ref1 === "on") {
    params.Grid = this.urlParams.grid === "on";
    guiElts.Grid = gui.add(params, 'Grid');
    guiElts.Grid.onFinishChange(function(val) {
      mathbox.select("#vecgrid").set("visible", val);
      return clipCube.uniforms.hilite.value = !val;
    });
  }
  view = this.view({
    grid: false,
    axes: this.urlParams.axes !== "disabled",
    axisOpts: {
      zIndex: 1
    }
  });
  this.mathbox.select(".view-axes").set("visible", params.Axes);
  lVectors = this.vectors.slice();
  lColors = this.colors.slice();
  lLabels = this.labels.slice();
  if (this.doTarget) {
    lVectors.push(this.target);
    lColors.push(this.targetColor);
    lLabels.push(this.targetLabel);
  }
  this.labeledVectors(view, {
    vectors: lVectors,
    colors: lColors,
    labels: lLabels,
    live: this.isLive,
    zeroPoints: true,
    zeroThreshold: 0.05,
    vectorOpts: {
      zIndex: 2
    },
    labelOpts: {
      zIndex: 2
    },
    zeroOpts: {
      zIndex: 3
    }
  });
  if (this.urlParams.lincombo !== "disabled") {
    linCombo = this.linearCombo(view, {
      coeffs: params,
      coeffVars: this.coeffs,
      vectors: this.vectors,
      colors: this.colors,
      labels: this.labels
    });
    this.mathbox.select(".lincombo").set("visible", params[checkLabel]);
  }
  surfaceColor = new THREE.Color(0.5, 0, 0);
  clipCube = this.clipCube(view, {
    draw: true,
    color: new THREE.Color(.75, .75, .75),
    material: new THREE.MeshBasicMaterial({
      color: surfaceColor,
      opacity: 0.5,
      transparent: true,
      visible: false,
      depthWrite: false,
      depthTest: true
    })
  });
  this.three.scene.add(clipCube.mesh);
  this.three.on('pre', function() {
    if (Math.abs(this.camera.position.x < 1.0) && Math.abs(this.camera.position.y < 1.0) && Math.abs(this.camera.position.z < 1.0)) {
      return clipCube.mesh.material.side = THREE.BackSide;
    } else {
      return clipCube.mesh.material.side = THREE.FrontSide;
    }
  });
  clipCube.uniforms.hilite.value = !params.Grid;
  range = this.urlParams.range != null ? parseFloat(this.urlParams.range) : 10.0;
  snapThreshold = 1.0 * range / 10.0;
  zeroThreshold = 0.00001;
  subspace = this.subspace({
    vectors: this.vectors,
    zeroThreshold: zeroThreshold,
    onDimChange: (function(_this) {
      return function(ss) {
        return clipCube.mesh.material.visible = ss.dim === 3 && (_this.urlParams.hidespace == null);
      };
    })(this),
    live: this.isLive
  });
  subspace.draw(clipCube.clipped);
  if ((ref2 = this.urlParams.grid) === "enabled" || ref2 === "on") {
    this.grid(clipCube.clipped, {
      vectors: this.vectors,
      live: this.isLive,
      lineOpts: {
        color: surfaceColor
      }
    });
    mathbox.select("#vecgrid").set("visible", this.urlParams.grid === "on");
  }
  snapped = new THREE.Vector3();
  diff = new THREE.Vector3();
  ss0 = this.subspace({
    vectors: [[0, 0, 0]]
  });
  ss1 = this.subspace({
    vectors: [[0, 0, 0]]
  });
  ss2 = this.subspace({
    vectors: [[0, 0, 0], [0, 0, 0]]
  });
  ss3 = this.subspace({
    vectors: [[0, 0, 0], [0, 0, 0], [0, 0, 0]]
  });
  subspaces = [ss0, ss1, ss2, ss3];
  snap = (function(_this) {
    return function(vec, vecs) {
      var ss;
      ss = subspaces[vecs.length];
      if (vecs.length > 0) {
        ss.setVecs(vecs);
      }
      ss.project(vec, snapped);
      diff.copy(vec).sub(snapped);
      if (diff.lengthSq() <= snapThreshold) {
        vec.copy(snapped);
        return true;
      }
      return false;
    };
  })(this);
  self = this;
  onDrag = function(vec) {
    var i, indices, j, k, len, other, others, ref3, results;
    if (snap(vec, [])) {
      return;
    }
    indices = (function() {
      results = [];
      for (var j = 0, ref3 = self.numVecs; 0 <= ref3 ? j < ref3 : j > ref3; 0 <= ref3 ? j++ : j--){ results.push(j); }
      return results;
    }).apply(this).filter((function(_this) {
      return function(x) {
        return x !== _this.dragging;
      };
    })(this));
    others = (function() {
      var k, len, results1;
      results1 = [];
      for (k = 0, len = indices.length; k < len; k++) {
        i = indices[k];
        results1.push(self.vectors[i]);
      }
      return results1;
    })();
    for (k = 0, len = others.length; k < len; k++) {
      other = others[k];
      if (snap(vec, [other])) {
        return;
      }
    }
    return snap(vec, others);
  };
  if (this.isLive) {
    this.draggable(view, {
      points: this.vectors,
      onDrag: onDrag,
      postDrag: (function(_this) {
        return function() {
          subspace.setVecs(_this.vectors);
          return updateCaption();
        };
      })(this)
    });
  }
  makeTexVecs = (function(_this) {
    return function() {
      var i, j, len, ref3, str, texVecs, vec;
      str = "\\left\\{";
      texVecs = [];
      ref3 = _this.vectors;
      for (i = j = 0, len = ref3.length; j < len; i = ++j) {
        vec = ref3[i];
        texVecs.push(_this.texVector(vec, {
          color: _this.hexColors[i]
        }));
      }
      return str += texVecs.join(",\\,") + "\\right\\}";
    };
  })(this);
  switch (this.urlParams.captions) {
    case "target":
      this.caption('<p>Solve this equation by moving the sliders:</p>\n<p><span id="eqn-here"></span>.</p>');
      eqnElt = document.getElementById('eqn-here');
      popup = this.popup('<h2>Success</h2>\n<p><span id="success-here"></span></p>');
      successElt = document.getElementById('success-here');
      updateCaption = (function(_this) {
        return function() {
          var equal, lc, str, str2;
          if (_this.urlParams.capopt === 'matrix') {
            str = _this.texMatrix(_this.vectors, {
              colors: _this.hexColors
            });
            str += _this.texVector((function() {
              var j, len, ref3, results;
              ref3 = this.coeffs;
              results = [];
              for (j = 0, len = ref3.length; j < len; j++) {
                c = ref3[j];
                results.push(params[c]);
              }
              return results;
            }).call(_this));
          } else {
            str = _this.texCombo(_this.vectors, (function() {
              var j, len, ref3, results;
              ref3 = this.coeffs;
              results = [];
              for (j = 0, len = ref3.length; j < len; j++) {
                c = ref3[j];
                results.push(params[c]);
              }
              return results;
            }).call(_this), {
              colors: _this.hexColors
            });
          }
          lc = linCombo.combine();
          str += " = " + _this.texVector(lc);
          equal = lc[0] === _this.target[0] && lc[1] === _this.target[1] && lc[2] === _this.target[2];
          str2 = str;
          str += equal ? " = " : " \\neq ";
          str += _this.texVector(_this.target);
          katex.render(str, eqnElt);
          if (equal) {
            katex.render(str2, successElt);
            return popup.show();
          } else {
            return popup.hide();
          }
        };
      })(this);
      ref3 = this.coeffs;
      for (j = 0, len = ref3.length; j < len; j++) {
        coeff = ref3[j];
        guiElts[coeff].onChange(function() {
          return updateCaption();
        });
      }
      break;
    case "combo":
      this.caption('<p><span id="eqn-here"></span></p>');
      eqnElt = document.getElementById('eqn-here');
      updateCaption = (function(_this) {
        return function() {
          var lc, str;
          if (_this.urlParams.capopt === 'matrix') {
            str = _this.texMatrix(_this.vectors, {
              colors: _this.hexColors
            });
            str += _this.texVector((function() {
              var k, len1, ref4, results;
              ref4 = this.coeffs;
              results = [];
              for (k = 0, len1 = ref4.length; k < len1; k++) {
                c = ref4[k];
                results.push(params[c]);
              }
              return results;
            }).call(_this));
          } else {
            str = _this.texCombo(_this.vectors, (function() {
              var k, len1, ref4, results;
              ref4 = this.coeffs;
              results = [];
              for (k = 0, len1 = ref4.length; k < len1; k++) {
                c = ref4[k];
                results.push(params[c]);
              }
              return results;
            }).call(_this), {
              colors: _this.hexColors
            });
          }
          lc = linCombo.combine();
          str += " = " + _this.texVector(lc);
          return katex.render(str, eqnElt);
        };
      })(this);
      ref4 = this.coeffs;
      for (k = 0, len1 = ref4.length; k < len1; k++) {
        coeff = ref4[k];
        guiElts[coeff].onChange(function() {
          return updateCaption();
        });
      }
      break;
    case "indep":
      this.caption('<p>The set <span id="vectors-here"></span>\n<span id="inter-is">is</span>\n<span id="span-type"></span>.</p>');
      vectorsElt = document.getElementById('vectors-here');
      spanElt = document.getElementById('span-type');
      updateCaption = (function(_this) {
        return function() {
          katex.render(makeTexVecs(), vectorsElt);
          if (subspace.dim === _this.numVecs) {
            return spanElt.innerText = "linearly independent";
          } else {
            return spanElt.innerText = "linearly dependent";
          }
        };
      })(this);
      break;
    default:
      this.caption('<p>Span <span id="vectors-here"></span>\n<span id="inter-is">is</span>\n<span id="span-type"></span>.</p>');
      vectorsElt = document.getElementById('vectors-here');
      spanElt = document.getElementById('span-type');
      updateCaption = (function(_this) {
        return function() {
          katex.render(makeTexVecs(), vectorsElt);
          return spanElt.innerText = ["a point", "a line", "a plane", "space"][subspace.dim];
        };
      })(this);
  }
  return updateCaption();
});


        });
    </script>
</body>
</html>

