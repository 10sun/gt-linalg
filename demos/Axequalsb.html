







<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="initial-scale=1, maximum-scale=1">
  <title>The function Ax=b</title>

      <link rel="stylesheet" href="mathbox/mathbox.css">
      <link rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css">
  

  <style>
      

html, body {
    margin:           0;
    height:           100%;
    background-color: #111111;
    overflow-x:       hidden;
}
.mathbox-wrapper {
    width:       50%;
    padding-top: 50%;
    position:    absolute;
    left:        0;
    top:         50%;
    transform:   translate(0, -50%);
}
.mathbox-wrapper + .mathbox-wrapper {
    left:        50%;
}
.mathbox-wrapper > div {
    position: absolute;
    top:      0;
    left:     0;
    width:    100%;
    height:   100%;
}
.mathbox-label {
    position:  absolute;
    left:      50%;
    top:       10px;
    color:     white;
    opacity:   1.0;
    background-color: rgba(50, 50, 50, .5);
    border:    solid 1px rgba(200, 200, 200, .5);
    padding:   5px;
    transform: translate(-50%, 0);
}
.overlay-text {
    z-index: 1;
}

#inconsistent {
    font-weight:   bold;
    font-size:     120%;
    padding-left:  1em;
    padding-right: 1em;
    color:         red;
    display:       none;
}
#matrix-here {
    display: none;
    text-align: center;
}
.overlay-text > p:last-child {
    text-align: center;
}

  </style>

  <link rel="stylesheet" href="css/demo.css">

</head>
<body>
    

<div class="overlay-text">
  <p id="matrix-here"><span id="the-matrix"></span></p>
  <p><span id="the-equation"></span>
      <span id="inconsistent">inconsistent</span></p>
  <p>[Click and drag the heads of x and b]</p>
</div>

<div class="mathbox-wrapper">
    <div id="mathbox1">
        
<div class="mathbox-label">Input</div>

    </div>
</div>
<div class="mathbox-wrapper">
    <div id="mathbox2">
        
<div class="mathbox-label">Output</div>

    </div>
</div>


        <script src="mathbox/mathbox-bundle.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.js">
        </script>
        <script src="lib/domready.js"></script>
        <script src="js/demo2.js"></script>
        <script src="lib/dat.gui.min.js"></script>
        <script src="lib/screenfull.min.js"></script>

    

    <script type="text/javascript">
        "use strict";
        DomReady.ready(function() {

        // Generated by CoffeeScript 1.10.0
var colBasis, cols, i, j, k, l, labeled, lockSolnsKey, matrix, outVec, params, ref, ref1, rows, showSolnsKey, solnspace, solve, tmp, updateCaption, vector;

vector = [-1, 2, 3];

outVec = [0, 0, 0];

colBasis = [];

showSolnsKey = "Show solution set";

lockSolnsKey = "Lock solution set";

solve = null;

solnspace = null;

params = null;

labeled = null;

updateCaption = null;

matrix = [[1, -1, 2], [-2, 2, -4]];

if (urlParams.mat != null) {
  matrix = urlParams.mat.split(":").map(function(s) {
    return s.split(",").map(parseFloat);
  });
}

rows = matrix.length;

cols = matrix[0].length;

tmp = [];

for (i = k = 0; k < 3; i = ++k) {
  tmp[i] = [];
  for (j = l = 0; l < 3; j = ++l) {
    tmp[i][j] = (ref = (ref1 = matrix[j]) != null ? ref1[i] : void 0) != null ? ref : 0;
  }
}

matrix = tmp;

window.demo1 = new (cols === 3 ? Demo : Demo2D)({
  mathbox: {
    element: document.getElementById("mathbox1")
  },
  scaleUI: false
}, function() {
  var Emat, c, clipCube, computeOut, eqnElt, gui, inconsElt, nulBasis, onDrag, r, ref2, ref3, str, tform, tmpVec, view;
  window.mathbox1 = this.mathbox;
  this.showSolns = true;
  this.lockSolns = false;
  if (this.urlParams.captions === 'rankthm') {
    vector = [0, 0, 0];
  }
  if (this.urlParams.show != null) {
    this.showSolns = this.urlParams.show === 'false' ? false : true;
  }
  if (this.urlParams.lock != null) {
    this.lockSolns = this.urlParams.lock != null ? true : false;
  }
  this.range = 5;
  if (this.urlParams.range1 != null) {
    this.range = parseFloat(this.urlParams.range1);
  }
  if (this.urlParams.x != null) {
    vector = this.urlParams.x.split(",").map(parseFloat);
  }
  if (vector[2] == null) {
    vector[2] = 0;
  }
  if (cols === 2) {
    vector[2] = 0;
  }
  this.tMatrix = new THREE.Matrix3();
  this.tMatrix.set(matrix[0][0], matrix[1][0], matrix[2][0], matrix[0][1], matrix[1][1], matrix[2][1], matrix[0][2], matrix[1][2], matrix[2][2]);
  tmpVec = new THREE.Vector3();
  params = {
    Axes: !((ref2 = this.urlParams.axes) === 'off' || ref2 === 'disabled'),
    Homogeneous: (function(_this) {
      return function() {
        vector[0] = vector[1] = vector[2] = 0;
        params[showSolnsKey] = true;
        params[lockSolnsKey] = true;
        solnspace.setVisibility(true);
        return computeOut();
      };
    })(this)
  };
  params[showSolnsKey] = this.showSolns;
  params[lockSolnsKey] = this.lockSolns;
  gui = new dat.GUI({
    width: 350
  });
  gui.closed = this.urlParams.closed != null;
  gui.add(params, 'Axes').onFinishChange((function(_this) {
    return function(val) {
      _this.mathbox.select(".view1-axes").set('visible', val);
      return demo2.mathbox.select(".view2-axes").set('visible', val);
    };
  })(this));
  gui.add(params, showSolnsKey).listen().onFinishChange((function(_this) {
    return function(val) {
      return solnspace.setVisibility(val);
    };
  })(this));
  gui.add(params, lockSolnsKey).listen();
  gui.add(params, 'Homogeneous');
  r = this.range;
  view = this.view({
    name: 'view1',
    viewRange: [[-r, r], [-r, r], [-r, r]].slice(0, cols),
    axisLabels: false
  });
  this.mathbox.select(".view1-axes").set('visible', params.Axes);
  labeled = this.labeledVectors(view, {
    vectors: [vector],
    colors: [[0, 1, 0, 1]],
    labels: ['x'],
    live: true,
    zeroPoints: true,
    zeroThreshold: 0.1,
    vectorOpts: {
      zIndex: 2
    },
    labelOpts: {
      zIndex: 3
    },
    zeroOpts: {
      zIndex: 3
    }
  });
  clipCube = this.clipCube(view, {
    draw: cols === 3,
    hilite: cols === 3,
    color: new THREE.Color(.75, .75, .75),
    material: new THREE.MeshBasicMaterial({
      color: new THREE.Color(0.5, 0, 0),
      opacity: 0.5,
      transparent: true,
      visible: false,
      depthWrite: false,
      depthTest: true
    })
  });
  ref3 = this.rowred((function() {
    var len, m, results;
    results = [];
    for (m = 0, len = matrix.length; m < len; m++) {
      c = matrix[m];
      results.push(c.slice());
    }
    return results;
  })(), {
    rows: rows,
    cols: cols
  }), nulBasis = ref3[0], colBasis = ref3[1], Emat = ref3[2], solve = ref3[3];
  this.nulspace = solnspace = this.subspace({
    name: 'nulspace',
    vectors: nulBasis,
    live: false,
    mesh: clipCube.mesh
  });
  tform = clipCube.clipped.transform().bind({
    position: (function(_this) {
      return function() {
        return vector;
      };
    })(this)
  });
  solnspace.draw(tform);
  if (solnspace.dim === 3) {
    clipCube.installMesh();
  }
  solnspace.setVisibility(params[showSolnsKey]);
  computeOut = (function(_this) {
    return function() {
      tmpVec.set.apply(tmpVec, vector).applyMatrix3(_this.tMatrix);
      outVec[0] = tmpVec.x;
      outVec[1] = tmpVec.y;
      outVec[2] = tmpVec.z;
      return updateCaption();
    };
  })(this);
  onDrag = (function(_this) {
    return function(vec) {
      if (params[showSolnsKey] && params[lockSolnsKey]) {
        tmpVec.set.apply(tmpVec, vector);
        solnspace.project(vec.sub(tmpVec), vec);
        return vec.add(tmpVec);
      }
    };
  })(this);
  this.draggable(view, {
    points: [vector],
    onDrag: onDrag,
    postDrag: computeOut
  });
  eqnElt = document.getElementById('the-equation');
  inconsElt = document.getElementById('inconsistent');
  switch (this.urlParams.captions) {
    case 'rankthm':
      document.getElementById('matrix-here').style.display = 'block';
      str = this.texMatrix(matrix, {
        rows: rows,
        cols: cols,
        precision: -1
      });
      katex.render('A=' + str, document.getElementById('the-matrix'));
      katex.render("\\text{rank}(A) = " + (cols - solnspace.dim) + " \\qquad\n\\text{dim Nul}(A) = " + solnspace.dim + " \\qquad\n\\#\\text{ columns of } A = " + cols, eqnElt);
      updateCaption = function() {};
      break;
    default:
      updateCaption = (function(_this) {
        return function() {
          str = _this.texMatrix(matrix, {
            rows: rows,
            cols: cols,
            precision: -1
          });
          if (labeled.hidden) {
            katex.render(str + '\\color{#00ff00}{x}' + ' = ' + _this.texVector(outVec, {
              color: '#ffff00',
              dim: rows
            }), eqnElt);
            return inconsElt.style.display = 'inline';
          } else {
            katex.render(str + _this.texVector(vector, {
              color: '#00ff00',
              dim: cols
            }) + ' = ' + _this.texVector(outVec, {
              color: '#ffff00',
              dim: rows
            }), eqnElt);
            return inconsElt.style.display = 'none';
          }
        };
      })(this);
  }
  return computeOut();
});

window.demo2 = new (rows === 3 ? Demo : Demo2D)({
  mathbox: {
    element: document.getElementById("mathbox2")
  },
  scaleUI: false
}, function() {
  var clipCube, computeIn, diff, onDrag, r, snapThreshold, snapped, subspace, tmpVec, view;
  window.mathbox2 = this.mathbox;
  this.range = 10;
  if (this.urlParams.range2 != null) {
    this.range = parseFloat(this.urlParams.range2);
  }
  r = this.range;
  view = this.view({
    name: 'view2',
    viewRange: [[-r, r], [-r, r], [-r, r]].slice(0, rows),
    axisLabels: false
  });
  this.mathbox.select(".view2-axes").set('visible', params.Axes);
  this.labeledVectors(view, {
    vectors: [outVec],
    colors: [[1, 1, 0, 1]],
    labels: ['b'],
    live: true,
    zeroPoints: true,
    zeroThreshold: 0.3,
    vectorOpts: {
      zIndex: 2
    },
    labelOpts: {
      zIndex: 3
    },
    zeroOpts: {
      zIndex: 3
    }
  });
  clipCube = this.clipCube(view, {
    draw: rows === 3,
    hilite: rows === 3,
    color: new THREE.Color(.75, .75, .75),
    material: new THREE.MeshBasicMaterial({
      color: new THREE.Color(0.5, 0, 0),
      opacity: 0.5,
      transparent: true,
      visible: false,
      depthWrite: false,
      depthTest: true
    })
  });
  subspace = this.subspace({
    name: 'colspace',
    vectors: colBasis,
    live: false
  });
  subspace.draw(clipCube.clipped);
  if (subspace.dim === 3) {
    clipCube.installMesh();
    clipCube.mesh.material.visible = true;
  }
  snapThreshold = 1.0 * 10.0 / this.range;
  snapped = new THREE.Vector3();
  diff = new THREE.Vector3();
  onDrag = (function(_this) {
    return function(vec) {
      subspace.project(vec, snapped);
      diff.copy(vec).sub(snapped);
      if (diff.lengthSq() <= snapThreshold) {
        return vec.copy(snapped);
      }
    };
  })(this);
  computeIn = function() {
    var inVec;
    inVec = solve(outVec);
    if (inVec != null) {
      if (inVec[2] == null) {
        inVec[2] = 0;
      }
      tmpVec.set(vector[0] - inVec[0], vector[1] - inVec[1], vector[2] - inVec[2]);
      solnspace.project(tmpVec, tmpVec);
      vector[0] = tmpVec.x + inVec[0];
      vector[1] = tmpVec.y + inVec[1];
      vector[2] = tmpVec.z + inVec[2];
      demo1.nulspace.setVisibility(params[showSolnsKey]);
      labeled.show();
    } else {
      demo1.nulspace.setVisibility(false);
      labeled.hide();
    }
    return updateCaption();
  };
  tmpVec = new THREE.Vector3();
  return this.draggable(view, {
    points: [outVec],
    onDrag: onDrag,
    postDrag: computeIn
  });
});

groupControls(demo1, demo2);


        });
    </script>
</body>
</html>

