






<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="initial-scale=1, maximum-scale=1">
  <title>The function Ax=b</title>

      <link rel="stylesheet" href="mathbox/mathbox.css">
      <link rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css">
  

  <style>
      
html, body {
    margin: 0;
    height: 100%;
}
#mathbox1 {
    width:    100%;
    height:   100%;
    position: relative;
    z-index:  0;
}
#inset-container {
    width : 30%;
    position: absolute;
    bottom:   0px;
    right:    0px;
    z-index:  1;
}
#inset-container2 {
    position: absolute;
    left:   0px;
    top:    0px;
    transform: translateY(-100%);
    width:  100%;
    padding-bottom: 100%;
    border: 2px solid #cccccc;
    box-sizing: border-box;
}
#mathbox2 {
    position: absolute;
    width:    100%;
    height:   100%;
}
#inconsistent {
    font-weight:   bold;
    font-size:     120%;
    padding-left:  1em;
    padding-right: 1em;
    color:         red;
    display:       none;
}
.overlay-text > p:last-child {
    text-align: center;
}

  </style>

  <link rel="stylesheet" href="css/demo.css">

</head>
<body>
    
<div id="mathbox1">
    <div id="inset-container">
        <div id="inset-container2">
            <div id="mathbox2"></div>
        </div>
    </div>
    <div class="overlay-text">
      <p><span id="the-equation"></span>
          <span id="inconsistent">inconsistent</span></p>
      <p>[Click and drag the heads of x and b]</p>
    </div>
</div>


        <script src="mathbox/mathbox-bundle.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.js">
        </script>
        <script src="lib/domready.js"></script>
        <script src="js/demo2.js"></script>
        <script src="lib/dat.gui.min.js"></script>
        <script src="lib/screenfull.min.js"></script>

    

    <script type="text/javascript">
        "use strict";
        DomReady.ready(function() {

        // Generated by CoffeeScript 1.10.0
var colBasis, labeled, lockSolnsKey, outVec, params, showSolnsKey, solnspace, solve, updateCaption, vector;

vector = [-1, 2, 3];

outVec = [0, 0];

colBasis = [];

showSolnsKey = "Show solution set";

lockSolnsKey = "Lock solution set";

solve = null;

solnspace = null;

params = null;

labeled = null;

updateCaption = null;

window.demo1 = new Demo({
  mathbox: {
    element: document.getElementById("mathbox1")
  }
}, function() {
  var Emat, c, clipCube, computeOut, eqnElt, gui, inconsElt, nulBasis, onDrag, ref, ref1, ref2, ref3, tform, tmpVec, view;
  window.mathbox1 = this.mathbox;
  this.showSolns = (ref = this.urlParams.show) != null ? ref : false;
  this.lockSolns = (ref1 = this.urlParams.lock) != null ? ref1 : true;
  this.matrix = [1, -1, 2, -2, 2, -4];
  if (this.urlParams.x != null) {
    vector = this.urlParams.x.split(",").map(parseFloat);
  }
  if (this.urlParams.mat != null) {
    this.matrix = this.urlParams.mat.split(",").map(parseFloat);
  }
  this.tMatrix = new THREE.Matrix3();
  this.tMatrix.set(this.matrix[0], this.matrix[1], this.matrix[2], this.matrix[3], this.matrix[4], this.matrix[5], 0, 0, 0);
  this.matrix = [[this.matrix[0], this.matrix[3]], [this.matrix[1], this.matrix[4]], [this.matrix[2], this.matrix[5]]];
  tmpVec = new THREE.Vector3();
  params = {
    Axes: !((ref2 = this.urlParams.axes) === 'off' || ref2 === 'disabled'),
    Homogeneous: (function(_this) {
      return function() {
        vector[0] = vector[1] = vector[2] = 0;
        params[showSolnsKey] = true;
        params[lockSolnsKey] = true;
        _this.mathbox.select('#solnset').set('visible', true);
        return computeOut();
      };
    })(this)
  };
  params[showSolnsKey] = this.showSolns;
  params[lockSolnsKey] = this.lockSolns;
  gui = new dat.GUI({
    width: 350
  });
  gui.add(params, 'Axes').onFinishChange((function(_this) {
    return function(val) {
      return _this.mathbox.select(".view-axes").set('visible', val);
    };
  })(this));
  gui.add(params, showSolnsKey).listen().onFinishChange((function(_this) {
    return function(val) {
      return _this.mathbox.select("#solnset").set('visible', val);
    };
  })(this));
  gui.add(params, lockSolnsKey).listen();
  gui.add(params, 'Homogeneous');
  view = this.view({
    name: 'view1',
    viewRange: [[-5, 5], [-5, 5], [-5, 5]]
  });
  this.mathbox.select(".view1-axes").set('visible', params.Axes);
  labeled = this.labeledVectors(view, {
    vectors: [vector],
    colors: [[0, 1, 0, 1]],
    labels: ['x'],
    live: true,
    zeroPoints: true,
    zeroThreshold: 0.1,
    vectorOpts: {
      zIndex: 2
    },
    labelOpts: {
      zIndex: 3
    },
    zeroOpts: {
      zIndex: 3
    }
  });
  clipCube = this.clipCube(view, {
    draw: true,
    color: new THREE.Color(.75, .75, .75)
  });
  ref3 = this.rowred((function() {
    var i, len, ref3, results;
    ref3 = this.matrix;
    results = [];
    for (i = 0, len = ref3.length; i < len; i++) {
      c = ref3[i];
      results.push(c.slice());
    }
    return results;
  }).call(this)), nulBasis = ref3[0], colBasis = ref3[1], Emat = ref3[2], solve = ref3[3];
  solnspace = this.subspace({
    name: 'nulspace',
    vectors: nulBasis,
    live: false,
    surfaceOpts: {
      id: 'solnset'
    }
  });
  tform = clipCube.clipped.transform().bind({
    position: (function(_this) {
      return function() {
        return vector;
      };
    })(this)
  });
  solnspace.draw(tform);
  this.mathbox.select("#solnset").set('visible', params[showSolnsKey]);
  computeOut = (function(_this) {
    return function() {
      tmpVec.set.apply(tmpVec, vector).applyMatrix3(_this.tMatrix);
      outVec[0] = tmpVec.x;
      outVec[1] = tmpVec.y;
      return updateCaption();
    };
  })(this);
  onDrag = (function(_this) {
    return function(vec) {
      if (params[showSolnsKey] && params[lockSolnsKey]) {
        tmpVec.set.apply(tmpVec, vector);
        solnspace.project(vec.sub(tmpVec), vec);
        return vec.add(tmpVec);
      }
    };
  })(this);
  this.draggable(view, {
    points: [vector],
    onDrag: onDrag,
    postDrag: computeOut
  });
  eqnElt = document.getElementById('the-equation');
  inconsElt = document.getElementById('inconsistent');
  updateCaption = (function(_this) {
    return function() {
      if (labeled.hidden) {
        katex.render(_this.texMatrix(_this.matrix, {
          rows: 2,
          precision: -1
        }) + '\\color{#00ff00}{x}' + ' = ' + _this.texVector(outVec, {
          color: '#ffff00',
          dim: 2
        }), eqnElt);
        return inconsElt.style.display = 'inline';
      } else {
        katex.render(_this.texMatrix(_this.matrix, {
          rows: 2,
          precision: -1
        }) + _this.texVector(vector, {
          color: '#00ff00'
        }) + ' = ' + _this.texVector(outVec, {
          color: '#ffff00',
          dim: 2
        }), eqnElt);
        return inconsElt.style.display = 'none';
      }
    };
  })(this);
  return computeOut();
});

window.demo2 = new Demo2D({
  mathbox: {
    element: document.getElementById("mathbox2")
  },
  scaleUI: false
}, function() {
  var clipCube, computeIn, diff, onDrag, snapThreshold, snapped, subspace, tmpVec, view;
  window.mathbox2 = this.mathbox;
  view = this.view({
    name: 'view2',
    axisLabels: false
  });
  this.labeledVectors(view, {
    vectors: [outVec],
    colors: [[1, 1, 0, 1]],
    labels: ['b'],
    live: true,
    zeroPoints: true,
    zeroThreshold: 0.3,
    vectorOpts: {
      zIndex: 2
    },
    labelOpts: {
      zIndex: 3
    },
    zeroOpts: {
      zIndex: 3
    }
  });
  clipCube = this.clipCube(view, {
    draw: false,
    hilite: false
  });
  subspace = this.subspace({
    name: 'colspace',
    vectors: colBasis,
    live: false
  });
  subspace.draw(clipCube.clipped);
  snapThreshold = 1.0;
  snapped = new THREE.Vector3();
  diff = new THREE.Vector3();
  onDrag = (function(_this) {
    return function(vec) {
      subspace.project(vec, snapped);
      diff.copy(vec).sub(snapped);
      if (diff.lengthSq() <= snapThreshold) {
        return vec.copy(snapped);
      }
    };
  })(this);
  computeIn = function() {
    var inVec;
    inVec = solve(outVec);
    if (inVec != null) {
      tmpVec.set(vector[0] - inVec[0], vector[1] - inVec[1], vector[2] - inVec[2]);
      solnspace.project(tmpVec, tmpVec);
      vector[0] = tmpVec.x + inVec[0];
      vector[1] = tmpVec.y + inVec[1];
      vector[2] = tmpVec.z + inVec[2];
      mathbox1.select("#solnset").set('visible', params[showSolnsKey]);
      labeled.show();
    } else {
      mathbox1.select("#solnset").set('visible', false);
      labeled.hide();
    }
    return updateCaption();
  };
  tmpVec = new THREE.Vector3();
  return this.draggable(view, {
    points: [outVec],
    onDrag: onDrag,
    postDrag: computeIn
  });
});


        });
    </script>
</body>
</html>

