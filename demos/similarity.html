









<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="initial-scale=1, maximum-scale=1">
  <title>Similar matrices</title>

      <link rel="stylesheet" href="mathbox/mathbox.css">
      <link rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css">
  

  <style>
      
    
html, body {
    margin:           0;
    height:           100%;
    background-color: #111111;
    overflow-x:       hidden;
}
.mathbox-wrapper {
    width:       50%;
    padding-top: 50%;
    position:    absolute;
    left:        0;
    top:         50%;
    transform:   translate(0, -50%);
}
.mathbox-wrapper + .mathbox-wrapper {
    left:        50%;
}
.mathbox-wrapper > div {
    position: absolute;
    top:      0;
    left:     0;
    width:    100%;
    height:   100%;
}
.mathbox-label {
    position:  absolute;
    left:      50%;
    top:       10px;
    color:     white;
    opacity:   1.0;
    background-color: rgba(50, 50, 50, .5);
    border:    solid 1px rgba(200, 200, 200, .5);
    padding:   5px;
    transform: translate(-50%, 0);
}
.overlay-text {
    z-index: 1;
}

    .matrix-powers {
        text-align: center;
        font-size: 150%;
    }
    .dots {
        text-align: center;
        font-size: 150%;
    }
    #mult-factor {
        text-align: center;
    }

  </style>

  <link rel="stylesheet" href="css/demo.css?version=2">

</head>
<body>
    

<div class="overlay-text">
</div>

<div class="mathbox-wrapper">
    <div id="mathbox1">
        
<div class="mathbox-label">The B-coordinates</div>

    </div>
</div>
<div class="mathbox-wrapper">
    <div id="mathbox2">
        
<div class="mathbox-label">The usual coordinates</div>

    </div>
</div>


        <script src="mathbox/mathbox-bundle.js?version=2"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.js">
        </script>
        <script src="lib/domready.js"></script>
        <script src="js/demo2.js?version=2"></script>
        <script src="lib/dat.gui.min.js"></script>
        <script src="lib/screenfull.min.js"></script>
    <script src="lib/expreval.js"></script>

    

    <script type="text/javascript">
        "use strict";
        DomReady.ready(function() {

        // Generated by CoffeeScript 1.10.0
var A, AName, B, BName, C, Ce1, Ce2, Ce3, Cinv, Dynamics, ShaderAnimation, colors, computeOut, dynamics, dynamicsMode, e1, e2, e3, gui, labels, mult33, params, ref, ref1, ref2, resetMode, shaderCode, shaders, size, snap, tB, tB4, tB4inv, tBinv, tC, tC4, tCinv, transpose, updateCaption, vectorIn1, vectorIn2, vectorOut1, vectorOut2,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

vectorIn1 = urlParams.get('x', 'float[]', [-1, 1, 3]);

vectorOut1 = [0, 0, 0];

vectorIn2 = [-1, 1, 3];

vectorOut2 = [0, 0, 0];

labels = urlParams.get('labels', 'str[]', ['v1', 'v2', 'v3']);

AName = (ref = urlParams.AName) != null ? ref : 'A';

BName = (ref1 = urlParams.BName) != null ? ref1 : 'B';

B = urlParams.get('B', 'matrix', [[2, 0], [0, 3]]);

C = urlParams.get('C', 'matrix', [[2, 1], [1, 1]]);

size = B.length;

if (size === 2) {
  vectorIn1[2] = 0;
  vectorIn2[2] = 0;
}

transpose = function(mat) {
  var i, j, k, l, ref2, ref3, tmp;
  tmp = [];
  for (i = k = 0; k < 3; i = ++k) {
    tmp[i] = [];
    for (j = l = 0; l < 3; j = ++l) {
      tmp[i][j] = (ref2 = (ref3 = mat[j]) != null ? ref3[i] : void 0) != null ? ref2 : 0;
    }
  }
  if (size === 2) {
    tmp[2][2] = 1;
  }
  return tmp;
};

B = transpose(B);

C = transpose(C);

tB = new THREE.Matrix3();

tB.set(B[0][0], B[1][0], B[2][0], B[0][1], B[1][1], B[2][1], B[0][2], B[1][2], B[2][2]);

tB4 = new THREE.Matrix4();

tB4.set(B[0][0], B[1][0], B[2][0], 0, B[0][1], B[1][1], B[2][1], 0, B[0][2], B[1][2], B[2][2], 0, 0, 0, 0, 1);

tB4inv = new THREE.Matrix4().getInverse(tB4);

tBinv = new THREE.Matrix3().getInverse(tB4);

tC = new THREE.Matrix3();

tC.set(C[0][0], C[1][0], C[2][0], C[0][1], C[1][1], C[2][1], C[0][2], C[1][2], C[2][2]);

tC4 = new THREE.Matrix4();

tC4.set(C[0][0], C[1][0], C[2][0], 0, C[0][1], C[1][1], C[2][1], 0, C[0][2], C[1][2], C[2][2], 0, 0, 0, 0, 1);

tCinv = new THREE.Matrix3().getInverse(tC4);

Cinv = tCinv.toArray();

Cinv = [[Cinv[0], Cinv[1], Cinv[2]], [Cinv[3], Cinv[4], Cinv[5]], [Cinv[6], Cinv[7], Cinv[8]]];

mult33 = function(mat1, mat2) {
  var out;
  out = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
  out[0][0] = mat1[0][0] * mat2[0][0] + mat1[1][0] * mat2[0][1] + mat1[2][0] * mat2[0][2];
  out[1][0] = mat1[0][0] * mat2[1][0] + mat1[1][0] * mat2[1][1] + mat1[2][0] * mat2[1][2];
  out[2][0] = mat1[0][0] * mat2[2][0] + mat1[1][0] * mat2[2][1] + mat1[2][0] * mat2[2][2];
  out[0][1] = mat1[0][1] * mat2[0][0] + mat1[1][1] * mat2[0][1] + mat1[2][1] * mat2[0][2];
  out[1][1] = mat1[0][1] * mat2[1][0] + mat1[1][1] * mat2[1][1] + mat1[2][1] * mat2[1][2];
  out[2][1] = mat1[0][1] * mat2[2][0] + mat1[1][1] * mat2[2][1] + mat1[2][1] * mat2[2][2];
  out[0][2] = mat1[0][2] * mat2[0][0] + mat1[1][2] * mat2[0][1] + mat1[2][2] * mat2[0][2];
  out[1][2] = mat1[0][2] * mat2[1][0] + mat1[1][2] * mat2[1][1] + mat1[2][2] * mat2[1][2];
  out[2][2] = mat1[0][2] * mat2[2][0] + mat1[1][2] * mat2[2][1] + mat1[2][2] * mat2[2][2];
  return out;
};

A = mult33(mult33(C, B), Cinv);

e1 = [1, 0, 0];

e2 = [0, 1, 0];

e3 = [0, 0, 1];

Ce1 = C[0];

Ce2 = C[1];

Ce3 = C[2];

colors = [[1, 1, 0, 1], [.7, .7, 0, .7], [.7, 0, 0, .8], [0, .7, 0, .8], [0, .3, .9, .8]].slice(0, size + 2);

updateCaption = null;

resetMode = null;

computeOut = null;

gui = null;

snap = false;

params = {};

if (urlParams.snap !== 'disabled') {
  gui = true;
  params["Snap axes"] = urlParams.snap !== 'off';
  gui = new dat.GUI;
  gui.closed = urlParams.closed != null;
  gui.add(params, "Snap axes").onFinishChange(function(val) {
    return snap = val;
  });
  snap = params["Snap axes"];
}

dynamicsMode = (ref2 = urlParams.dynamics) != null ? ref2 : 'off';

shaderCode = '#define M_PI 3.1415926535897932384626433832795\n\nuniform float pos;\nuniform mat4 start;\nuniform mat4 end;\nuniform float scale;\nuniform int which;\n\nvec4 animateLinear(vec4 xyzw) {\n    vec4 endpos = end * xyzw;\n    xyzw = start * xyzw;\n    return pos * endpos + (1.0 - pos) * xyzw;\n}\n\nvec4 animateScaleSteps(vec4 xyzw) {\n    vec4 startpos, endpos;\n    float pos2;\n    if(pos < 0.5) {\n        startpos = start * xyzw;\n        endpos = startpos;\n        endpos.x *= end[0][0] / start[0][0];\n        pos2 = pos * 2.0;\n    } else {\n        startpos = start * xyzw;\n        startpos.x *= end[0][0] / start[0][0];\n        endpos = end * xyzw;\n        pos2 = (pos - 0.5) * 2.0;\n    }\n    return pos2 * endpos + (1.0 - pos2) * startpos;\n}\n\nvec4 animateExponential(vec4 xyzw) {\n    vec4 endpos = end * xyzw;\n    xyzw = start * xyzw;\n    if(pos == 0.0)\n        return xyzw;\n    if(pos == 1.0)\n        return endpos;\n    // pos is in (0, 1)\n    return pow(abs(xyzw), vec4(1.0 - pos)) * pow(abs(endpos), vec4(pos)) * sign(xyzw);\n}\n\nvec4 rotate(vec4 xyzw, float pos2) {\n    float startangle = atan(start[0][1], start[0][0]);\n    float endangle   = atan(end[0][1],   end[0][0]);\n    // Go around the short way\n    if(abs(endangle - startangle) > M_PI) {\n        if(endangle > startangle)\n            endangle -= 2.0*M_PI;\n        else\n            endangle += 2.0*M_PI;\n    }\n    endangle -= startangle;\n    float angle = pos2 * endangle;\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec4(xyzw.x * c - xyzw.y * s, xyzw.x * s + xyzw.y * c, xyzw.z, xyzw.w);\n}\n\nvec4 animateRotation(vec4 xyzw) {\n    if(pos == 0.0)\n        return start * xyzw;\n    return rotate(start * xyzw, pos);\n}\n\nvec4 animateRotateScale(vec4 xyzw) {\n    if(pos == 0.0)\n        return start * xyzw;\n    if(pos < 0.5)\n        return rotate(start * xyzw, pos * 2.0);\n    float pos2 = (pos - 0.5) * 2.0;\n    xyzw = end * xyzw;\n    xyzw.xy *= ((1.0 - pos2) / scale + pos2 * 1.0);\n    return xyzw;\n}\n\nvec4 animateSpiral(vec4 xyzw) {\n    if(pos == 0.0)\n        return start * xyzw;\n    xyzw = rotate(start * xyzw, pos);\n    xyzw.xy *= pow(scale, pos);\n    return xyzw;\n}\n\nvec4 animate(vec4 xyzw, inout vec4 stpq) {\n    if(which == 0)\n        return animateLinear(xyzw);\n    if(which == 1)\n        return animateScaleSteps(xyzw);\n    if(which == 2)\n        return animateExponential(xyzw);\n    if(which == 3)\n        return animateRotation(xyzw);\n    if(which == 4)\n        return animateRotateScale(xyzw);\n    if(which == 5)\n        return animateSpiral(xyzw);\n}';

shaders = {
  linear: 0,
  scaleSteps: 1,
  exponential: 2,
  rotation: 3,
  rotateScale: 4,
  spiral: 5
};

ShaderAnimation = (function(superClass) {
  extend(ShaderAnimation, superClass);

  function ShaderAnimation(opts) {
    this.done = bind(this.done, this);
    this.stop = bind(this.stop, this);
    this.updateMat = bind(this.updateMat, this);
    this.resetMat = bind(this.resetMat, this);
    this.setShader = bind(this.setShader, this);
    this.pos = bind(this.pos, this);
    this.install = bind(this.install, this);
    var ref3;
    if (opts == null) {
      opts = {};
    }
    this.startTime = null;
    this.duration = (ref3 = opts.duration) != null ? ref3 : 1;
    this.startMat = new THREE.Matrix4();
    this.endMat = new THREE.Matrix4();
    ShaderAnimation.__super__.constructor.apply(this, arguments);
  }

  ShaderAnimation.prototype.install = function(view, shader) {
    this.uniforms = {
      start: {
        type: 'm4',
        value: this.startMat
      },
      end: {
        type: 'm4',
        value: this.endMat
      },
      scale: {
        type: 'f',
        value: 1
      },
      which: {
        type: 'i',
        value: shader
      }
    };
    this.animShader = view.shader({
      code: shaderCode,
      uniforms: this.uniforms
    }, {
      pos: this.pos
    });
    return this.vertex = view.vertex({
      shader: this.animShader,
      pass: 'data'
    });
  };

  ShaderAnimation.prototype.pos = function(t) {
    var pos;
    if (!this.running) {
      return 0;
    }
    if (this.startTime === null) {
      this.startTime = t;
      return 0;
    }
    pos = (t - this.startTime) / this.duration;
    if (pos >= 1) {
      this.done();
      return 0;
    }
    return pos;
  };

  ShaderAnimation.prototype.setShader = function(shader) {
    return this.uniforms.which.value = shader;
  };

  ShaderAnimation.prototype.resetMat = function() {
    this.startMat.identity();
    return this.endMat.identity();
  };

  ShaderAnimation.prototype.updateMat = function(newMat) {
    return this.endMat.multiply(newMat);
  };

  ShaderAnimation.prototype.stop = function() {
    this.startMat.copy(this.endMat);
    this.uniforms.scale.value = 1;
    this.startTime = null;
    return ShaderAnimation.__super__.stop.apply(this, arguments);
  };

  ShaderAnimation.prototype.done = function() {
    this.startMat.copy(this.endMat);
    this.uniforms.scale.value = 1;
    this.startTime = null;
    return ShaderAnimation.__super__.done.apply(this, arguments);
  };

  return ShaderAnimation;

})(Animation);

Dynamics = (function() {
  function Dynamics(range) {
    var col, det, folder, motions, references;
    this.range = range;
    this.iterate = bind(this.iterate, this);
    this.reset = bind(this.reset, this);
    this.updateReferences = bind(this.updateReferences, this);
    this.makeRefData = bind(this.makeRefData, this);
    this.makeVecs = bind(this.makeVecs, this);
    this.hide = bind(this.hide, this);
    this.show = bind(this.show, this);
    this.install = bind(this.install, this);
    this.numVecs = urlParams.get('numvecs', 'int', 500 * 5 * 5);
    this.vecs = (function() {
      var k, ref3, results;
      results = [];
      for (k = 0, ref3 = this.numVecs; 0 <= ref3 ? k < ref3 : k > ref3; 0 <= ref3 ? k++ : k--) {
        results.push([0, 0, 0]);
      }
      return results;
    }).call(this);
    col = function() {
      return Math.random() * .5 + .5;
    };
    this.colors = (function() {
      var k, ref3, results;
      results = [];
      for (k = 0, ref3 = this.numVecs; 0 <= ref3 ? k < ref3 : k > ref3; 0 <= ref3 ? k++ : k--) {
        results.push([col(), col(), col(), 1]);
      }
      return results;
    }).call(this);
    this.makeVecs();
    this.captionColors = (function() {
      var k, results;
      results = [];
      for (k = 0; k < 15; k++) {
        results.push([col(), col(), col(), 1]);
      }
      return results;
    })();
    this.points = [];
    this.pointsData = [];
    this.refDataElts = [];
    this.refLines = [];
    this.animations = [];
    this.tmpVec = new THREE.Vector3();
    this.refData = null;
    if (B[0][0] === B[1][1] && B[1][0] === -B[0][1]) {
      this.matType = 'rot-scale';
    } else if (B[0][1] === 0 && B[1][0] === 0) {
      this.matType = 'diag';
    } else {
      this.matType = 'none';
    }
    this.mat = tB4;
    this.matInv = tB4inv;
    if (gui == null) {
      gui = new dat.GUI;
    }
    gui.closed = urlParams.closed != null;
    this.iteration = 0;
    folder = gui.addFolder("Dynamics");
    if (dynamicsMode === 'on') {
      folder.open();
    }
    params.Enable = dynamicsMode === 'on';
    params.Reset = this.reset;
    params.Iterate = (function(_this) {
      return function() {
        return _this.iterate(1);
      };
    })(this);
    params.UnIterate = (function(_this) {
      return function() {
        return _this.iterate(-1);
      };
    })(this);
    params.Motion = urlParams.motion;
    params.Reference = urlParams.reference;
    switch (this.matType) {
      case 'rot-scale':
        motions = ['linear', 'rotateScale'];
        det = B[0][0] * B[1][1] + B[0][1] * B[0][1];
        if (Math.abs(det - 1) < 1e-6) {
          if (params.Motion == null) {
            params.Motion = 'rotation';
          }
          motions[1] = 'rotation';
          if (params.Reference == null) {
            params.Reference = 'circle';
          }
          references = ['none', 'circle'];
        } else {
          if (params.Motion == null) {
            params.Motion = 'spiral';
          }
          motions.push('spiral');
          if (params.Reference == null) {
            params.Reference = 'spiral';
          }
          references = ['none', 'circle', 'spiral'];
        }
        break;
      case 'diag':
        if (B[0][0] === 1 || B[1][1] === 1) {
          if (params.Motion == null) {
            params.Motion = 'linear';
          }
          motions = false;
          if (params.Reference == null) {
            params.Reference = 'lines';
          }
          references = ['none', 'lines'];
        } else if (B[0][0] < 0 || B[1][1] < 0) {
          if (params.Motion == null) {
            params.Motion = 'scaleSteps';
          }
          motions = ['linear', 'scaleSteps'];
          references = false;
        } else {
          if (params.Motion == null) {
            params.Motion = 'exponential';
          }
          motions = ['linear', 'scaleSteps', 'exponential'];
          if (params.Reference == null) {
            params.Reference = 'exp';
          }
          references = ['none', 'exp'];
        }
        break;
      default:
        if (params.Motion == null) {
          params.Motion = 'linear';
        }
        motions = false;
        references = false;
    }
    folder.add(params, 'Enable').onFinishChange(function(val) {
      dynamicsMode = val ? 'on' : 'off';
      resetMode();
      return updateCaption();
    });
    if (motions) {
      folder.add(params, 'Motion', motions).onFinishChange((function(_this) {
        return function(val) {
          var anim, k, len, ref3, results;
          ref3 = _this.animations;
          results = [];
          for (k = 0, len = ref3.length; k < len; k++) {
            anim = ref3[k];
            results.push(anim.setShader(shaders[val]));
          }
          return results;
        };
      })(this));
    }
    if (references) {
      folder.add(params, 'Reference', references).onFinishChange(this.updateReferences);
    }
    folder.add(params, 'Reset');
    folder.add(params, 'Iterate');
    folder.add(params, 'UnIterate');
  }

  Dynamics.prototype.install = function(view) {
    var animation, points, pointsData, refDataElt, refLine;
    animation = new ShaderAnimation();
    animation.install(view, shaders[params.Motion]);
    this.animations.push(animation);
    colors = view.array({
      channels: 4,
      width: this.numVecs,
      data: this.colors,
      live: false
    });
    pointsData = animation.vertex.array({
      channels: 3,
      width: this.numVecs,
      data: this.vecs,
      live: false
    });
    points = pointsData.point({
      colors: colors,
      color: "white",
      size: 10,
      zIndex: 3
    });
    this.pointsData.push(pointsData);
    this.points.push(points);
    if (params.Reference) {
      this.makeRefData();
      refDataElt = view.array({
        channels: 3,
        width: this.refData.length,
        items: this.refData[0].length,
        data: this.refData,
        live: false
      });
      refLine = view.line({
        color: "rgb(0, 80, 255)",
        width: 4,
        opacity: .75,
        zBias: 2,
        closed: true,
        visible: params.Reference !== 'none'
      });
      this.refDataElts.push(refDataElt);
      return this.refLines.push(refLine);
    }
  };

  Dynamics.prototype.show = function() {
    var elt, k, l, len, len1, ref3, ref4, results;
    ref3 = this.points;
    for (k = 0, len = ref3.length; k < len; k++) {
      elt = ref3[k];
      elt.set('visible', true);
    }
    if (params.Reference) {
      ref4 = this.refLines;
      results = [];
      for (l = 0, len1 = ref4.length; l < len1; l++) {
        elt = ref4[l];
        results.push(elt.set('visible', true));
      }
      return results;
    }
  };

  Dynamics.prototype.hide = function() {
    var elt, k, l, len, len1, ref3, ref4, results;
    ref3 = this.points;
    for (k = 0, len = ref3.length; k < len; k++) {
      elt = ref3[k];
      elt.set('visible', false);
    }
    if (params.Reference) {
      ref4 = this.refLines;
      results = [];
      for (l = 0, len1 = ref4.length; l < len1; l++) {
        elt = ref4[l];
        results.push(elt.set('visible', false));
      }
      return results;
    }
  };

  Dynamics.prototype.makeVecs = function() {
    var i, k, r, ref3, results;
    r = 5 * this.range;
    results = [];
    for (i = k = 0, ref3 = this.numVecs; 0 <= ref3 ? k < ref3 : k > ref3; i = 0 <= ref3 ? ++k : --k) {
      this.vecs[i][0] = Math.random() * 2 * r - r;
      results.push(this.vecs[i][1] = Math.random() * 2 * r - r);
    }
    return results;
  };

  Dynamics.prototype.makeRefData = function() {
    var i, j, k, l, len, m, n, o, p, ref3, ref4, ref5, ref6, ref7, results, results1, results2, results3, row, s, scale, scaleX, scaleY, sx, sy, t, θ;
    scale = Math.sqrt(B[0][0] * B[1][1] + B[0][1] * B[0][1]);
    if (Math.abs(scale - 1) < 1e-6) {
      scale = Math.sqrt(2);
    }
    switch (params.Reference) {
      case 'circle':
        this.refData = (function() {
          var k, results;
          results = [];
          for (k = 0; k <= 50; k++) {
            results.push((function() {
              var l, results1;
              results1 = [];
              for (l = -5; l <= 5; l++) {
                results1.push([0, 0, 0]);
              }
              return results1;
            })());
          }
          return results;
        })();
        results = [];
        for (j = k = -5; k <= 5; j = ++k) {
          s = Math.pow(scale, j);
          results.push((function() {
            var l, results1;
            results1 = [];
            for (i = l = 0; l <= 50; i = ++l) {
              this.refData[i][j + 5][0] = Math.cos(2 * π * i / 50) * s;
              results1.push(this.refData[i][j + 5][1] = Math.sin(2 * π * i / 50) * s);
            }
            return results1;
          }).call(this));
        }
        return results;
        break;
      case 'spiral':
        θ = Math.atan2(B[0][1], B[0][0]);
        this.refData = [];
        results1 = [];
        for (t = l = ref3 = -5 * π, ref4 = 5 * π, ref5 = π / 36; ref5 > 0 ? l < ref4 : l > ref4; t = l += ref5) {
          s = Math.pow(scale, t / θ);
          results1.push(this.refData.push((function() {
            var m, ref6, ref7, results2;
            results2 = [];
            for (j = m = 0, ref6 = 2 * π, ref7 = π / 4; ref7 > 0 ? m < ref6 : m > ref6; j = m += ref7) {
              results2.push([s * Math.cos(t + j), s * Math.sin(t + j), 0]);
            }
            return results2;
          })()));
        }
        return results1;
        break;
      case 'exp':
        scaleX = B[0][0];
        scaleY = B[1][1];
        this.refData = [];
        results2 = [];
        for (i = m = -40; m <= 40; i = ++m) {
          sx = Math.pow(scaleX, i / 6);
          sy = Math.pow(scaleY, i / 6);
          row = [];
          if ((scaleX > 1 && scaleY < 1) || (scaleX < 1 && scaleY > 1)) {
            for (j = n = ref6 = 1 / 10; n <= 10; j = n += .3) {
              row.push([sx * j, sy * j, 0]);
              row.push([-sx * j, sy * j, 0]);
              row.push([sx * j, -sy * j, 0]);
              row.push([-sx * j, -sy * j, 0]);
            }
          } else {
            for (j = o = 0.05; o <= 0.96; j = o += .05) {
              row.push([sx * j, sy * (1 - j), 0]);
              row.push([-sx * j, sy * (1 - j), 0]);
              row.push([sx * j, -sy * (1 - j), 0]);
              row.push([-sx * j, -sy * (1 - j), 0]);
            }
          }
          results2.push(this.refData.push(row));
        }
        return results2;
        break;
      case 'lines':
        scaleX = B[0][0];
        scaleY = B[1][1];
        this.refData = [];
        ref7 = [-5 * this.range, 5 * this.range];
        results3 = [];
        for (p = 0, len = ref7.length; p < len; p++) {
          i = ref7[p];
          if (scaleX === 1) {
            this.refData.push((function() {
              var q, ref10, ref8, ref9, results4;
              results4 = [];
              for (j = q = ref8 = -2 * this.range, ref9 = 2 * this.range, ref10 = this.range / 10; ref10 > 0 ? q <= ref9 : q >= ref9; j = q += ref10) {
                results4.push([j, i, 0]);
              }
              return results4;
            }).call(this));
          }
          if (scaleY === 1) {
            results3.push(this.refData.push((function() {
              var q, ref10, ref8, ref9, results4;
              results4 = [];
              for (j = q = ref8 = -2 * this.range, ref9 = 2 * this.range, ref10 = this.range / 10; ref10 > 0 ? q <= ref9 : q >= ref9; j = q += ref10) {
                results4.push([i, j, 0]);
              }
              return results4;
            }).call(this)));
          } else {
            results3.push(void 0);
          }
        }
        return results3;
        break;
      case 'none':
        return this.refData = [[[0, 0, 0]]];
    }
  };

  Dynamics.prototype.updateReferences = function(val) {
    var elt, k, l, len, len1, len2, line, m, ref3, ref4, ref5, results, results1;
    if (val === 'none') {
      ref3 = this.refLines;
      results = [];
      for (k = 0, len = ref3.length; k < len; k++) {
        line = ref3[k];
        results.push(line.set('visible', false));
      }
      return results;
    } else {
      this.makeRefData();
      ref4 = this.refDataElts;
      for (l = 0, len1 = ref4.length; l < len1; l++) {
        elt = ref4[l];
        elt.set({
          width: this.refData.length,
          items: this.refData[0].length,
          data: this.refData
        });
      }
      ref5 = this.refLines;
      results1 = [];
      for (m = 0, len2 = ref5.length; m < len2; m++) {
        line = ref5[m];
        results1.push(line.set('visible', true));
      }
      return results1;
    }
  };

  Dynamics.prototype.reset = function() {
    var anim, demo, k, l, len, len1, ref3, ref4;
    if (!params.Enable) {
      return;
    }
    ref3 = this.animations;
    for (k = 0, len = ref3.length; k < len; k++) {
      anim = ref3[k];
      anim.resetMat();
    }
    this.makeVecs();
    ref4 = [demo1, demo2];
    for (l = 0, len1 = ref4.length; l < len1; l++) {
      demo = ref4[l];
      demo.stopAll();
    }
    this.iteration = 0;
    resetMode();
    return updateCaption();
  };

  Dynamics.prototype.iterate = function(direction) {
    var demo, i, iter, k, l, len, len1, mat, me, ref3, ref4;
    iter = this.iteration + direction;
    mat = direction > 0 ? this.mat : this.matInv;
    ref3 = [demo1, demo2];
    for (k = 0, len = ref3.length; k < len; k++) {
      demo = ref3[k];
      demo.stopAll();
    }
    ref4 = [demo1, demo2];
    for (i = l = 0, len1 = ref4.length; l < len1; i = ++l) {
      demo = ref4[i];
      this.animations[i].updateMat(mat);
      if (this.matType === 'rot-scale') {
        me = mat.elements;
        this.animations[i].uniforms.scale.value = Math.sqrt(me[0] * me[0] + me[1] * me[1]);
      }
      demo.animate({
        animation: this.animations[i]
      });
    }
    document.getElementById('mult-factor').innerText = 'Vectors multiplied by';
    katex.render((BName + "^{" + iter + "} ") + ("\\quad\\text{resp.}\\quad " + AName + "^{" + iter + "}"), document.getElementById('An-here'));
    return this.iteration = iter;
  };

  return Dynamics;

})();

dynamics = null;

window.demo1 = new (size === 3 ? Demo : Demo2D)({
  mathbox: {
    element: document.getElementById("mathbox1")
  }
}, function() {
  var clipCube, diff, labeled, onDrag, r, snapThreshold, snapped, subspace1, subspace2, subspace3, subspaces, tmpVec, view;
  window.mathbox1 = this.mathbox;
  this.range = this.urlParams.get('range1', 'float', 5);
  r = this.range;
  view = this.view({
    name: 'view1',
    viewRange: [[-r, r], [-r, r], [-r, r]].slice(0, size),
    axes: false,
    grid: false
  });
  labeled = this.labeledVectors(view, {
    vectors: [vectorIn1, vectorOut1, e1, e2, e3].slice(0, size + 2),
    colors: colors,
    labels: ['[x]_B', BName + '[x]_B', 'e1', 'e2', 'e3'].slice(0, size + 2),
    live: true,
    zeroPoints: dynamicsMode === 'disabled',
    zeroThreshold: 0.3,
    vectorOpts: {
      zIndex: 2
    },
    labelOpts: {
      zIndex: 3
    },
    zeroOpts: {
      zIndex: 3
    }
  });
  clipCube = this.clipCube(view, {
    draw: true,
    hilite: size === 3,
    color: new THREE.Color(.75, .75, .75)
  });
  if (dynamicsMode !== 'disabled') {
    dynamics = new Dynamics(this.range);
    dynamics.install(clipCube.clipped);
  }
  clipCube.clipped.area({
    width: 11,
    height: 11,
    channels: size,
    rangeX: [-r, r],
    rangeY: [-r, r]
  }).surface({
    color: "white",
    opacity: 0.5,
    lineX: true,
    lineY: true,
    fill: false,
    zBias: 0
  }).array({
    channels: 4,
    width: 2,
    items: size,
    data: [[colors[2], colors[3], colors[4]].slice(0, size), [colors[2], colors[3], colors[4]].slice(0, size)]
  }).array({
    width: 2,
    items: size,
    channels: size,
    data: size === 2 ? [[-r, 0], [0, -r], [r, 0], [0, r]] : [[-r, 0, 0], [0, -r, 0], [0, 0, -r], [r, 0, 0], [0, r, 0], [0, 0, r]]
  }).line({
    color: "white",
    colors: "<<",
    width: 3,
    opacity: 1,
    zBias: 1
  });
  tmpVec = new THREE.Vector3();
  computeOut = (function(_this) {
    return function() {
      tmpVec.set.apply(tmpVec, vectorIn1).applyMatrix3(tB);
      vectorOut1[0] = tmpVec.x;
      vectorOut1[1] = tmpVec.y;
      vectorOut1[2] = tmpVec.z;
      tmpVec.applyMatrix3(tC);
      vectorOut2[0] = tmpVec.x;
      vectorOut2[1] = tmpVec.y;
      vectorOut2[2] = tmpVec.z;
      tmpVec.set.apply(tmpVec, vectorIn1).applyMatrix3(tC);
      vectorIn2[0] = tmpVec.x;
      vectorIn2[1] = tmpVec.y;
      vectorIn2[2] = tmpVec.z;
      return updateCaption();
    };
  })(this);
  snapThreshold = 1.0 * this.range / 10.0;
  snapped = new THREE.Vector3();
  diff = new THREE.Vector3();
  subspace1 = this.subspace({
    vectors: [e1]
  });
  subspace2 = this.subspace({
    vectors: [e2]
  });
  subspace3 = this.subspace({
    vectors: [e3]
  });
  subspaces = [subspace1, subspace2, subspace3];
  onDrag = (function(_this) {
    return function(vec) {
      var k, len, results, subspace;
      if (!snap) {
        return;
      }
      results = [];
      for (k = 0, len = subspaces.length; k < len; k++) {
        subspace = subspaces[k];
        subspace.project(vec, snapped);
        diff.copy(vec).sub(snapped);
        if (diff.lengthSq() <= snapThreshold) {
          results.push(vec.copy(snapped));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };
  })(this);
  this.draggable(view, {
    points: [vectorIn1],
    onDrag: onDrag,
    postDrag: computeOut
  });
  return resetMode = (function(_this) {
    return function() {
      var col, demo, eq1Elt, eq2Elt, hexColor, k, l, len, len1, len2, m, matsElt, ref3, ref4, ref5, results, results1, str;
      if (dynamicsMode === 'on') {
        updateCaption = function() {};
        str = '<p class="dots">';
        ref3 = dynamics.captionColors;
        for (k = 0, len = ref3.length; k < len; k++) {
          col = ref3[k];
          hexColor = "#" + new THREE.Color(col[0], col[1], col[2]).getHexString();
          str += "<span style=\"color:" + hexColor + "\">&#x25cf;</span>";
        }
        str += '</p>';
        document.getElementsByClassName('overlay-text')[0].innerHTML = str + '<p id="mult-factor">Original vectors</p>\n<p class="matrix-powers">\n    <span id="An-here"></span>\n</p>';
        dynamics.show();
        ref4 = [demo1, demo2];
        results = [];
        for (l = 0, len1 = ref4.length; l < len1; l++) {
          demo = ref4[l];
          results.push(demo.mathbox.select('.labeled').set('visible', false));
        }
        return results;
      } else {
        document.getElementsByClassName('overlay-text')[0].innerHTML = '<p><span id="mats-here"></span></p>\n<p><span id="eq1-here"></span> (B-coordinates)</p>\n<p><span id="eq2-here"></span></p>';
        matsElt = document.getElementById('mats-here');
        eq1Elt = document.getElementById('eq1-here');
        eq2Elt = document.getElementById('eq2-here');
        str = _this.texMatrix(A, {
          rows: size,
          cols: size
        });
        str += '=';
        str += _this.texMatrix(C, {
          rows: size,
          cols: size
        });
        str += _this.texMatrix(B, {
          rows: size,
          cols: size
        });
        str += _this.texMatrix(Cinv, {
          rows: size,
          cols: size
        });
        katex.render(str, matsElt);
        updateCaption = function() {
          str = _this.texMatrix(B, {
            rows: size,
            cols: size
          });
          str += _this.texVector(vectorIn1, {
            dim: size,
            color: "#ffff00"
          });
          str += '=';
          str += _this.texVector(vectorOut1, {
            dim: size,
            color: "#888800"
          });
          katex.render(str, eq1Elt);
          str = _this.texMatrix(A, {
            rows: size,
            cols: size
          });
          str += _this.texVector(vectorIn2, {
            dim: size,
            color: "#ff00ff"
          });
          str += '=';
          str += _this.texVector(vectorOut2, {
            dim: size,
            color: "#880088"
          });
          return katex.render(str, eq2Elt);
        };
        if (dynamics) {
          dynamics.hide();
          ref5 = [demo1, demo2];
          results1 = [];
          for (m = 0, len2 = ref5.length; m < len2; m++) {
            demo = ref5[m];
            results1.push(demo.mathbox.select('.labeled').set('visible', true));
          }
          return results1;
        }
      }
    };
  })(this);
});

window.demo2 = new (size === 3 ? Demo : Demo2D)({
  mathbox: {
    element: document.getElementById("mathbox2")
  }
}, function() {
  var clipCube, colors2, computeIn, diff, labeled, onDrag, r, r2, snapThreshold, snapped, subspace1, subspace2, subspace3, subspaces, tmpVec, view;
  window.mathbox2 = this.mathbox;
  this.range = this.urlParams.get('range2', 'float', 5);
  r = this.range;
  view = this.view({
    name: 'view2',
    viewRange: [[-r, r], [-r, r], [-r, r]].slice(0, size),
    axes: false,
    grid: false
  });
  colors2 = colors.slice();
  colors2[0] = [1, 0, 1, 1];
  colors2[1] = [.7, 0, .7, .7];
  labeled = this.labeledVectors(view, {
    vectors: [vectorIn2, vectorOut2, Ce1, Ce2, Ce3].slice(0, size + 2),
    colors: colors2,
    labels: ['x', AName + 'x'].concat(labels).slice(0, size + 2),
    live: true,
    zeroPoints: dynamicsMode === 'disabled',
    zeroThreshold: 0.3,
    vectorOpts: {
      zIndex: 2
    },
    labelOpts: {
      zIndex: 3
    },
    zeroOpts: {
      zIndex: 3
    }
  });
  clipCube = this.clipCube(view, {
    draw: true,
    hilite: size === 3,
    color: new THREE.Color(.75, .75, .75)
  });
  this.transformed = clipCube.clipped.transform({
    matrix: [C[0][0], C[1][0], C[2][0], 0, C[0][1], C[1][1], C[2][1], 0, C[0][2], C[1][2], C[2][2], 0, 0, 0, 0, 1]
  });
  r2 = demo1.range * 5;
  this.transformed.area({
    width: 51,
    height: 51,
    channels: size,
    rangeX: [-r2, r2],
    rangeY: [-r2, r2]
  }).surface({
    color: "white",
    opacity: 0.5,
    lineX: true,
    lineY: true,
    fill: false,
    zBias: 0
  }).array({
    channels: 4,
    width: 2,
    items: size,
    data: [[colors[2], colors[3], colors[4]].slice(0, size), [colors[2], colors[3], colors[4]].slice(0, size)]
  }).array({
    width: 2,
    items: size,
    channels: size,
    data: size === 2 ? [[-r2, 0], [0, -r2], [r2, 0], [0, r2]] : [[-r2, 0, 0], [0, -r2, 0], [0, 0, -r2], [r2, 0, 0], [0, r2, 0], [0, 0, r2]]
  }).line({
    color: "white",
    colors: "<<",
    width: 3,
    opacity: 1,
    zBias: 1
  });
  if (dynamics) {
    dynamics.install(this.transformed);
  }
  tmpVec = new THREE.Vector3();
  computeIn = function() {
    tmpVec.set.apply(tmpVec, vectorIn2).applyMatrix3(tCinv);
    vectorIn1[0] = tmpVec.x;
    vectorIn1[1] = tmpVec.y;
    vectorIn1[2] = tmpVec.z;
    tmpVec.applyMatrix3(tB);
    vectorOut1[0] = tmpVec.x;
    vectorOut1[1] = tmpVec.y;
    vectorOut1[2] = tmpVec.z;
    tmpVec.applyMatrix3(tC);
    vectorOut2[0] = tmpVec.x;
    vectorOut2[1] = tmpVec.y;
    vectorOut2[2] = tmpVec.z;
    return updateCaption();
  };
  snapThreshold = 1.0 * this.range / 10.0;
  snapped = new THREE.Vector3();
  diff = new THREE.Vector3();
  subspace1 = this.subspace({
    vectors: [Ce1]
  });
  subspace2 = this.subspace({
    vectors: [Ce2]
  });
  subspace3 = this.subspace({
    vectors: [Ce3]
  });
  subspaces = [subspace1, subspace2, subspace3];
  onDrag = (function(_this) {
    return function(vec) {
      var k, len, results, subspace;
      if (!snap) {
        return;
      }
      results = [];
      for (k = 0, len = subspaces.length; k < len; k++) {
        subspace = subspaces[k];
        subspace.project(vec, snapped);
        diff.copy(vec).sub(snapped);
        if (diff.lengthSq() <= snapThreshold) {
          results.push(vec.copy(snapped));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };
  })(this);
  return this.draggable(view, {
    points: [vectorIn2],
    onDrag: onDrag,
    postDrag: computeIn
  });
});

groupControls(demo1, demo2);

resetMode();

computeOut();


        });
    </script>
</body>
</html>

