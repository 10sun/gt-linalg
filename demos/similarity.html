







<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="initial-scale=1, maximum-scale=1">
  <title>Similar matrices</title>

      <link rel="stylesheet" href="mathbox/mathbox.css">
      <link rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css">
  

  <style>
      
html, body {
    margin:           0;
    height:           100%;
    background-color: #111111;
    overflow-x:       hidden;
}
.mathbox-wrapper {
    width:       50%;
    padding-top: 50%;
    position:    absolute;
    left:        0;
    top:         50%;
    transform:   translate(0, -50%);
}
.mathbox-wrapper + .mathbox-wrapper {
    left:        50%;
}
.mathbox-wrapper > div {
    position: absolute;
    top:      0;
    left:     0;
    width:    100%;
    height:   100%;
}
.mathbox-label {
    position:  absolute;
    left:      50%;
    top:       10px;
    color:     white;
    opacity:   1.0;
    background-color: rgba(50, 50, 50, .5);
    border:    solid 1px rgba(200, 200, 200, .5);
    padding:   5px;
    transform: translate(-50%, 0);
}
.overlay-text {
    z-index: 1;
}

  </style>

  <link rel="stylesheet" href="css/demo.css">

</head>
<body>
    

<div class="overlay-text">
    <p><span id="mats-here"></span></p>
    <p><span id="eq1-here"></span> (B-coordinates)</p>
    <p><span id="eq2-here"></span></p>
</div>

<div class="mathbox-wrapper">
    <div id="mathbox1">
        
<div class="mathbox-label">The B-coordinates</div>

    </div>
</div>
<div class="mathbox-wrapper">
    <div id="mathbox2">
        
<div class="mathbox-label">The usual coordinates</div>

    </div>
</div>


        <script src="mathbox/mathbox-bundle.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.js">
        </script>
        <script src="lib/domready.js"></script>
        <script src="js/demo2.js"></script>
        <script src="lib/dat.gui.min.js"></script>
        <script src="lib/screenfull.min.js"></script>

    

    <script type="text/javascript">
        "use strict";
        DomReady.ready(function() {

        // Generated by CoffeeScript 1.10.0
var A, B, C, Ce1, Ce2, Ce3, Cinv, colors, e1, e2, e3, gui, mult33, params, size, snap, tB, tC, tC4, tCinv, transpose, updateCaption, vectorIn1, vectorIn2, vectorOut1, vectorOut2;

vectorIn1 = [-1, 1, 3];

vectorOut1 = [0, 0, 0];

vectorIn2 = [-1, 1, 3];

vectorOut2 = [0, 0, 0];

if (urlParams.x != null) {
  vectorIn1 = urlParams.x.split(",").map(parseFloat);
}

B = [[2, 0], [0, 3]];

C = [[2, 1], [1, 1]];

if (urlParams.B != null) {
  B = urlParams.B.split(":").map(function(s) {
    return s.split(",").map(parseFloat);
  });
}

if (urlParams.C != null) {
  C = urlParams.C.split(":").map(function(s) {
    return s.split(",").map(parseFloat);
  });
}

size = B.length;

if (size === 2) {
  vectorIn1[2] = 0;
  vectorIn2[2] = 0;
}

transpose = function(mat) {
  var i, j, k, l, ref, ref1, tmp;
  tmp = [];
  for (i = k = 0; k < 3; i = ++k) {
    tmp[i] = [];
    for (j = l = 0; l < 3; j = ++l) {
      tmp[i][j] = (ref = (ref1 = mat[j]) != null ? ref1[i] : void 0) != null ? ref : 0;
    }
  }
  if (size === 2) {
    tmp[2][2] = 1;
  }
  return tmp;
};

B = transpose(B);

C = transpose(C);

tB = new THREE.Matrix3();

tB.set(B[0][0], B[1][0], B[2][0], B[0][1], B[1][1], B[2][1], B[0][2], B[1][2], B[2][2]);

tC = new THREE.Matrix3();

tC.set(C[0][0], C[1][0], C[2][0], C[0][1], C[1][1], C[2][1], C[0][2], C[1][2], C[2][2]);

tC4 = new THREE.Matrix4();

tC4.set(C[0][0], C[1][0], C[2][0], 0, C[0][1], C[1][1], C[2][1], 0, C[0][2], C[1][2], C[2][2], 0, 0, 0, 0, 1);

tCinv = new THREE.Matrix3().getInverse(tC4);

Cinv = tCinv.toArray();

Cinv = [[Cinv[0], Cinv[3], Cinv[6]], [Cinv[1], Cinv[4], Cinv[7]], [Cinv[2], Cinv[5], Cinv[8]]];

mult33 = function(mat1, mat2) {
  var out;
  out = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
  out[0][0] = mat1[0][0] * mat2[0][0] + mat1[1][0] * mat2[0][1] + mat1[2][0] * mat2[0][2];
  out[1][0] = mat1[0][0] * mat2[1][0] + mat1[1][0] * mat2[1][1] + mat1[2][0] * mat2[1][2];
  out[2][0] = mat1[0][0] * mat2[2][0] + mat1[1][0] * mat2[2][1] + mat1[2][0] * mat2[2][2];
  out[0][1] = mat1[0][1] * mat2[0][0] + mat1[1][1] * mat2[0][1] + mat1[2][1] * mat2[0][2];
  out[1][1] = mat1[0][1] * mat2[1][0] + mat1[1][1] * mat2[1][1] + mat1[2][1] * mat2[1][2];
  out[2][1] = mat1[0][1] * mat2[2][0] + mat1[1][1] * mat2[2][1] + mat1[2][1] * mat2[2][2];
  out[0][2] = mat1[0][2] * mat2[0][0] + mat1[1][2] * mat2[0][1] + mat1[2][2] * mat2[0][2];
  out[1][2] = mat1[0][2] * mat2[1][0] + mat1[1][2] * mat2[1][1] + mat1[2][2] * mat2[1][2];
  out[2][2] = mat1[0][2] * mat2[2][0] + mat1[1][2] * mat2[2][1] + mat1[2][2] * mat2[2][2];
  return out;
};

A = mult33(mult33(C, B), Cinv);

e1 = [1, 0, 0];

e2 = [0, 1, 0];

e3 = [0, 0, 1];

Ce1 = C[0];

Ce2 = C[1];

Ce3 = C[2];

colors = [[1, 1, 0, 1], [.7, .7, 0, .7], [.7, 0, 0, .8], [0, .7, 0, .8], [0, .3, .9, .8]].slice(0, size + 2);

updateCaption = null;

snap = false;

if (urlParams.snap !== 'disabled') {
  params = {
    "Snap axes": urlParams.snap !== 'off'
  };
  gui = new dat.GUI;
  gui.closed = urlParams.closed != null;
  gui.add(params, "Snap axes").onFinishChange(function(val) {
    return snap = val;
  });
  snap = params["Snap axes"];
}

window.demo1 = new (size === 3 ? Demo : Demo2D)({
  mathbox: {
    element: document.getElementById("mathbox1")
  }
}, function() {
  var clipCube, computeOut, diff, eq1Elt, eq2Elt, labeled, matsElt, onDrag, r, snapThreshold, snapped, str, subspace1, subspace2, subspace3, subspaces, tmpVec, view;
  window.mathbox1 = this.mathbox;
  this.range = 5;
  if (this.urlParams.range1 != null) {
    this.range = parseFloat(this.urlParams.range1);
  }
  r = this.range;
  view = this.view({
    name: 'view1',
    viewRange: [[-r, r], [-r, r], [-r, r]].slice(0, size),
    axes: false,
    grid: false
  });
  labeled = this.labeledVectors(view, {
    vectors: [vectorIn1, vectorOut1, e1, e2, e3].slice(0, size + 2),
    colors: colors,
    labels: ['[x]_B', 'B[x]_B', 'e1', 'e2', 'e3'].slice(0, size + 2),
    live: true,
    zeroPoints: true,
    zeroThreshold: 0.3,
    vectorOpts: {
      zIndex: 2
    },
    labelOpts: {
      zIndex: 3
    },
    zeroOpts: {
      zIndex: 3
    }
  });
  clipCube = this.clipCube(view, {
    draw: true,
    hilite: size === 3,
    color: new THREE.Color(.75, .75, .75)
  });
  clipCube.clipped.area({
    width: 11,
    height: 11,
    channels: size,
    rangeX: [-r, r],
    rangeY: [-r, r]
  }).surface({
    color: "white",
    opacity: 0.5,
    lineX: true,
    lineY: true,
    fill: false,
    zBias: 0
  }).array({
    channels: 4,
    width: 2,
    items: size,
    data: [[colors[2], colors[3], colors[4]].slice(0, size), [colors[2], colors[3], colors[4]].slice(0, size)]
  }).array({
    width: 2,
    items: size,
    channels: size,
    data: size === 2 ? [[-r, 0], [0, -r], [r, 0], [0, r]] : [[-r, 0, 0], [0, -r, 0], [0, 0, -r], [r, 0, 0], [0, r, 0], [0, 0, r]]
  }).line({
    color: "white",
    colors: "<<",
    width: 3,
    opacity: 1,
    zBias: 1
  });
  tmpVec = new THREE.Vector3();
  computeOut = (function(_this) {
    return function() {
      tmpVec.set.apply(tmpVec, vectorIn1).applyMatrix3(tB);
      vectorOut1[0] = tmpVec.x;
      vectorOut1[1] = tmpVec.y;
      vectorOut1[2] = tmpVec.z;
      tmpVec.applyMatrix3(tC);
      vectorOut2[0] = tmpVec.x;
      vectorOut2[1] = tmpVec.y;
      vectorOut2[2] = tmpVec.z;
      tmpVec.set.apply(tmpVec, vectorIn1).applyMatrix3(tC);
      vectorIn2[0] = tmpVec.x;
      vectorIn2[1] = tmpVec.y;
      vectorIn2[2] = tmpVec.z;
      return updateCaption();
    };
  })(this);
  snapThreshold = 1.0 * this.range / 10.0;
  snapped = new THREE.Vector3();
  diff = new THREE.Vector3();
  subspace1 = this.subspace({
    vectors: [e1]
  });
  subspace2 = this.subspace({
    vectors: [e2]
  });
  subspace3 = this.subspace({
    vectors: [e3]
  });
  subspaces = [subspace1, subspace2, subspace3];
  onDrag = (function(_this) {
    return function(vec) {
      var k, len, results, subspace;
      results = [];
      for (k = 0, len = subspaces.length; k < len; k++) {
        subspace = subspaces[k];
        subspace.project(vec, snapped);
        diff.copy(vec).sub(snapped);
        if (diff.lengthSq() <= snapThreshold) {
          results.push(vec.copy(snapped));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };
  })(this);
  this.draggable(view, {
    points: [vectorIn1],
    onDrag: onDrag,
    postDrag: computeOut
  });
  matsElt = document.getElementById('mats-here');
  eq1Elt = document.getElementById('eq1-here');
  eq2Elt = document.getElementById('eq2-here');
  str = this.texMatrix(A, {
    rows: size,
    cols: size,
    precision: -1
  });
  str += '=';
  str += this.texMatrix(C, {
    rows: size,
    cols: size,
    precision: -1
  });
  str += this.texMatrix(B, {
    rows: size,
    cols: size,
    precision: -1
  });
  str += this.texMatrix(Cinv, {
    rows: size,
    cols: size,
    precision: -1
  });
  katex.render(str, matsElt);
  updateCaption = (function(_this) {
    return function() {
      str = _this.texMatrix(B, {
        rows: size,
        cols: size,
        precision: -1
      });
      str += _this.texVector(vectorIn1, {
        dim: size,
        color: "#ffff00"
      });
      str += '=';
      str += _this.texVector(vectorOut1, {
        dim: size,
        color: "#888800"
      });
      katex.render(str, eq1Elt);
      str = _this.texMatrix(A, {
        rows: size,
        cols: size,
        precision: -1
      });
      str += _this.texVector(vectorIn2, {
        dim: size,
        color: "#ff00ff"
      });
      str += '=';
      str += _this.texVector(vectorOut2, {
        dim: size,
        color: "#880088"
      });
      return katex.render(str, eq2Elt);
    };
  })(this);
  return computeOut();
});

window.demo2 = new (size === 3 ? Demo : Demo2D)({
  mathbox: {
    element: document.getElementById("mathbox2")
  }
}, function() {
  var clipCube, colors2, computeOut, diff, labeled, onDrag, r, snapThreshold, snapped, subspace1, subspace2, subspace3, subspaces, tmpVec, view;
  window.mathbox2 = this.mathbox;
  this.range = 5;
  if (this.urlParams.range2 != null) {
    this.range = parseFloat(this.urlParams.range2);
  }
  r = this.range;
  view = this.view({
    name: 'view2',
    viewRange: [[-r, r], [-r, r], [-r, r]].slice(0, size),
    axes: false,
    grid: false
  });
  colors2 = colors.slice();
  colors2[0] = [1, 0, 1, 1];
  colors2[1] = [.7, 0, .7, .7];
  labeled = this.labeledVectors(view, {
    vectors: [vectorIn2, vectorOut2, Ce1, Ce2, Ce3].slice(0, size + 2),
    colors: colors2,
    labels: ['x', 'Ax', 'v1', 'v2', 'v3'].slice(0, size + 2),
    live: true,
    zeroPoints: true,
    zeroThreshold: 0.3,
    vectorOpts: {
      zIndex: 2
    },
    labelOpts: {
      zIndex: 3
    },
    zeroOpts: {
      zIndex: 3
    }
  });
  clipCube = this.clipCube(view, {
    draw: true,
    hilite: size === 3,
    color: new THREE.Color(.75, .75, .75)
  });
  clipCube.clipped.transform({
    matrix: [C[0][0], C[1][0], C[2][0], 0, C[0][1], C[1][1], C[2][1], 0, C[0][2], C[1][2], C[2][2], 0, 0, 0, 0, 1]
  }).area({
    width: 51,
    height: 51,
    channels: size,
    rangeX: [-5 * r, 5 * r],
    rangeY: [-5 * r, 5 * r]
  }).surface({
    color: "white",
    opacity: 0.5,
    lineX: true,
    lineY: true,
    fill: false,
    zBias: 0
  }).array({
    channels: 4,
    width: 2,
    items: size,
    data: [[colors[2], colors[3], colors[4]].slice(0, size), [colors[2], colors[3], colors[4]].slice(0, size)]
  }).array({
    width: 2,
    items: size,
    channels: size,
    data: size === 2 ? [[-r, 0], [0, -r], [r, 0], [0, r]] : [[-r, 0, 0], [0, -r, 0], [0, 0, -r], [r, 0, 0], [0, r, 0], [0, 0, r]]
  }).line({
    color: "white",
    colors: "<<",
    width: 3,
    opacity: 1,
    zBias: 1
  });
  tmpVec = new THREE.Vector3();
  computeOut = function() {
    tmpVec.set.apply(tmpVec, vectorIn2).applyMatrix3(tCinv);
    vectorIn1[0] = tmpVec.x;
    vectorIn1[1] = tmpVec.y;
    vectorIn1[2] = tmpVec.z;
    tmpVec.applyMatrix3(tB);
    vectorOut1[0] = tmpVec.x;
    vectorOut1[1] = tmpVec.y;
    vectorOut1[2] = tmpVec.z;
    tmpVec.applyMatrix3(tC);
    vectorOut2[0] = tmpVec.x;
    vectorOut2[1] = tmpVec.y;
    vectorOut2[2] = tmpVec.z;
    return updateCaption();
  };
  snapThreshold = 1.0 * this.range / 10.0;
  snapped = new THREE.Vector3();
  diff = new THREE.Vector3();
  subspace1 = this.subspace({
    vectors: [Ce1]
  });
  subspace2 = this.subspace({
    vectors: [Ce2]
  });
  subspace3 = this.subspace({
    vectors: [Ce3]
  });
  subspaces = [subspace1, subspace2, subspace3];
  onDrag = (function(_this) {
    return function(vec) {
      var k, len, results, subspace;
      results = [];
      for (k = 0, len = subspaces.length; k < len; k++) {
        subspace = subspaces[k];
        subspace.project(vec, snapped);
        diff.copy(vec).sub(snapped);
        if (diff.lengthSq() <= snapThreshold) {
          results.push(vec.copy(snapped));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };
  })(this);
  return this.draggable(view, {
    points: [vectorIn2],
    onDrag: onDrag,
    postDrag: computeOut
  });
});

groupControls(demo1, demo2);


        });
    </script>
</body>
</html>

