







<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="initial-scale=1, maximum-scale=1">
  <title>Similar matrices</title>

      <link rel="stylesheet" href="mathbox/mathbox.css">
      <link rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css">
  

  <style>
      
    
html, body {
    margin:           0;
    height:           100%;
    background-color: #111111;
    overflow-x:       hidden;
}
.mathbox-wrapper {
    width:       50%;
    padding-top: 50%;
    position:    absolute;
    left:        0;
    top:         50%;
    transform:   translate(0, -50%);
}
.mathbox-wrapper + .mathbox-wrapper {
    left:        50%;
}
.mathbox-wrapper > div {
    position: absolute;
    top:      0;
    left:     0;
    width:    100%;
    height:   100%;
}
.mathbox-label {
    position:  absolute;
    left:      50%;
    top:       10px;
    color:     white;
    opacity:   1.0;
    background-color: rgba(50, 50, 50, .5);
    border:    solid 1px rgba(200, 200, 200, .5);
    padding:   5px;
    transform: translate(-50%, 0);
}
.overlay-text {
    z-index: 1;
}

    .matrix-powers {
        text-align: center;
        font-size: 150%;
    }
    .dots {
        text-align: center;
        font-size: 150%;
    }
    #mult-factor {
        text-align: center;
    }

  </style>

  <link rel="stylesheet" href="css/demo.css">

</head>
<body>
    

<div class="overlay-text">
</div>

<div class="mathbox-wrapper">
    <div id="mathbox1">
        
<div class="mathbox-label">The B-coordinates</div>

    </div>
</div>
<div class="mathbox-wrapper">
    <div id="mathbox2">
        
<div class="mathbox-label">The usual coordinates</div>

    </div>
</div>


        <script src="mathbox/mathbox-bundle.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.js">
        </script>
        <script src="lib/domready.js"></script>
        <script src="js/demo2.js"></script>
        <script src="lib/dat.gui.min.js"></script>
        <script src="lib/screenfull.min.js"></script>

    

    <script type="text/javascript">
        "use strict";
        DomReady.ready(function() {

        // Generated by CoffeeScript 1.10.0
var A, AName, B, BName, C, Ce1, Ce2, Ce3, Cinv, colors, computeOut, dynamicsMode, e1, e2, e3, folder, gui, inFolder, iterate, iteration, labels, makeRandom, makeRefData, mult33, numVecs, params, random, randomColors, ref, ref1, ref2, refData, reference, referenceItems, resetMode, size, snap, tB, tB4, tBinv, tC, tC4, tCinv, tmpVec2, transpose, updateCaption, updateRefData, vectorIn1, vectorIn2, vectorOut1, vectorOut2;

vectorIn1 = [-1, 1, 3];

vectorOut1 = [0, 0, 0];

vectorIn2 = [-1, 1, 3];

vectorOut2 = [0, 0, 0];

if (urlParams.x != null) {
  vectorIn1 = urlParams.x.split(",").map(parseFloat);
}

labels = ['v1', 'v2', 'v3'];

if (urlParams.labels != null) {
  labels = urlParams.labels.split(',');
}

AName = (ref = urlParams.AName) != null ? ref : 'A';

BName = (ref1 = urlParams.BName) != null ? ref1 : 'B';

B = [[2, 0], [0, 3]];

C = [[2, 1], [1, 1]];

if (urlParams.B != null) {
  B = urlParams.B.split(":").map(function(s) {
    return s.split(",").map(parseFloat);
  });
}

if (urlParams.C != null) {
  C = urlParams.C.split(":").map(function(s) {
    return s.split(",").map(parseFloat);
  });
}

size = B.length;

if (size === 2) {
  vectorIn1[2] = 0;
  vectorIn2[2] = 0;
}

transpose = function(mat) {
  var i, j, k, l, ref2, ref3, tmp;
  tmp = [];
  for (i = k = 0; k < 3; i = ++k) {
    tmp[i] = [];
    for (j = l = 0; l < 3; j = ++l) {
      tmp[i][j] = (ref2 = (ref3 = mat[j]) != null ? ref3[i] : void 0) != null ? ref2 : 0;
    }
  }
  if (size === 2) {
    tmp[2][2] = 1;
  }
  return tmp;
};

B = transpose(B);

C = transpose(C);

tB = new THREE.Matrix3();

tB.set(B[0][0], B[1][0], B[2][0], B[0][1], B[1][1], B[2][1], B[0][2], B[1][2], B[2][2]);

tB4 = new THREE.Matrix4();

tB4.set(B[0][0], B[1][0], B[2][0], 0, B[0][1], B[1][1], B[2][1], 0, B[0][2], B[1][2], B[2][2], 0, 0, 0, 0, 1);

tBinv = new THREE.Matrix3().getInverse(tB4);

tC = new THREE.Matrix3();

tC.set(C[0][0], C[1][0], C[2][0], C[0][1], C[1][1], C[2][1], C[0][2], C[1][2], C[2][2]);

tC4 = new THREE.Matrix4();

tC4.set(C[0][0], C[1][0], C[2][0], 0, C[0][1], C[1][1], C[2][1], 0, C[0][2], C[1][2], C[2][2], 0, 0, 0, 0, 1);

tCinv = new THREE.Matrix3().getInverse(tC4);

Cinv = tCinv.toArray();

Cinv = [[Cinv[0], Cinv[1], Cinv[2]], [Cinv[3], Cinv[4], Cinv[5]], [Cinv[6], Cinv[7], Cinv[8]]];

mult33 = function(mat1, mat2) {
  var out;
  out = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
  out[0][0] = mat1[0][0] * mat2[0][0] + mat1[1][0] * mat2[0][1] + mat1[2][0] * mat2[0][2];
  out[1][0] = mat1[0][0] * mat2[1][0] + mat1[1][0] * mat2[1][1] + mat1[2][0] * mat2[1][2];
  out[2][0] = mat1[0][0] * mat2[2][0] + mat1[1][0] * mat2[2][1] + mat1[2][0] * mat2[2][2];
  out[0][1] = mat1[0][1] * mat2[0][0] + mat1[1][1] * mat2[0][1] + mat1[2][1] * mat2[0][2];
  out[1][1] = mat1[0][1] * mat2[1][0] + mat1[1][1] * mat2[1][1] + mat1[2][1] * mat2[1][2];
  out[2][1] = mat1[0][1] * mat2[2][0] + mat1[1][1] * mat2[2][1] + mat1[2][1] * mat2[2][2];
  out[0][2] = mat1[0][2] * mat2[0][0] + mat1[1][2] * mat2[0][1] + mat1[2][2] * mat2[0][2];
  out[1][2] = mat1[0][2] * mat2[1][0] + mat1[1][2] * mat2[1][1] + mat1[2][2] * mat2[1][2];
  out[2][2] = mat1[0][2] * mat2[2][0] + mat1[1][2] * mat2[2][1] + mat1[2][2] * mat2[2][2];
  return out;
};

A = mult33(mult33(C, B), Cinv);

e1 = [1, 0, 0];

e2 = [0, 1, 0];

e3 = [0, 0, 1];

Ce1 = C[0];

Ce2 = C[1];

Ce3 = C[2];

numVecs = 20;

random = (function() {
  var k, ref2, results;
  results = [];
  for (k = 0, ref2 = numVecs; 0 <= ref2 ? k < ref2 : k > ref2; 0 <= ref2 ? k++ : k--) {
    results.push([0, 0, 0]);
  }
  return results;
})();

randomColors = (function() {
  var k, ref2, results;
  results = [];
  for (k = 0, ref2 = numVecs; 0 <= ref2 ? k < ref2 : k > ref2; 0 <= ref2 ? k++ : k--) {
    results.push([0, 0, 0, 1]);
  }
  return results;
})();

makeRandom = null;

dynamicsMode = 'off';

if (urlParams.dynamics != null) {
  dynamicsMode = urlParams.dynamics;
}

colors = [[1, 1, 0, 1], [.7, .7, 0, .7], [.7, 0, 0, .8], [0, .7, 0, .8], [0, .3, .9, .8]].slice(0, size + 2);

updateCaption = null;

resetMode = null;

computeOut = null;

gui = null;

snap = false;

params = {};

if (urlParams.snap !== 'disabled') {
  gui = true;
  params["Snap axes"] = urlParams.snap !== 'off';
  gui = new dat.GUI;
  gui.closed = urlParams.closed != null;
  gui.add(params, "Snap axes").onFinishChange(function(val) {
    return snap = val;
  });
  snap = params["Snap axes"];
}

if (dynamicsMode !== 'disabled') {
  tmpVec2 = new THREE.Vector3();
  reference = (ref2 = urlParams.reference) != null ? ref2 : null;
  refData = null;
  makeRefData = function() {};
  switch (reference) {
    case 'circle':
      makeRefData = function() {
        var i;
        return refData = (function() {
          var k, results;
          results = [];
          for (i = k = 0; k <= 50; i = ++k) {
            results.push([Math.cos(2 * π * i / 50), Math.sin(2 * π * i / 50), 0]);
          }
          return results;
        })();
      };
      updateRefData = function(mat) {
        var k, len, newData, vec;
        newData = [];
        for (k = 0, len = refData.length; k < len; k++) {
          vec = refData[k];
          tmpVec2.set.apply(tmpVec2, vec).applyMatrix3(mat);
          newData.push([tmpVec2.x, tmpVec2.y, tmpVec2.z]);
        }
        return newData;
      };
      referenceItems = 1;
      break;
    case 'hyperbola':
      makeRefData = function() {
        var i;
        return refData = (function() {
          var k, results;
          results = [];
          for (i = k = -25; k <= 25; i = ++k) {
            results.push([[Math.pow(2, i / 3), Math.pow(2, -i / 3), 0], [-(Math.pow(2, i / 3)), Math.pow(2, -i / 3), 0], [Math.pow(2, i / 3), -(Math.pow(2, -i / 3)), 0], [-(Math.pow(2, i / 3)), -(Math.pow(2, -i / 3)), 0]]);
          }
          return results;
        })();
      };
      updateRefData = function(mat) {};
      referenceItems = 4;
  }
  makeRefData();
  inFolder = gui != null;
  if (gui == null) {
    gui = new dat.GUI;
  }
  gui.closed = urlParams.closed != null;
  iteration = 0;
  folder = gui.addFolder("Dynamics");
  if (dynamicsMode === 'on') {
    folder.open();
  }
  params.Enable = dynamicsMode === 'on';
  params.Reset = function() {
    var demo, k, len, ref3;
    if (!params.Enable) {
      return;
    }
    makeRandom();
    makeRefData();
    ref3 = [demo1, demo2];
    for (k = 0, len = ref3.length; k < len; k++) {
      demo = ref3[k];
      demo.stopAll();
      demo.pointsData.set('data', random);
      if (reference) {
        demo.refData.set('data', refData);
      }
    }
    iteration = 0;
    resetMode();
    return updateCaption();
  };
  iterate = function(mat, iter) {
    var demo, k, l, len, len1, len2, m, newData, newRandom, ref3, ref4, vec;
    ref3 = [demo1, demo2];
    for (k = 0, len = ref3.length; k < len; k++) {
      demo = ref3[k];
      demo.stopAll();
      demo.pointsData.set('data', random);
    }
    newRandom = [];
    for (l = 0, len1 = random.length; l < len1; l++) {
      vec = random[l];
      tmpVec2.set.apply(tmpVec2, vec).applyMatrix3(mat);
      newRandom.push([tmpVec2.x, tmpVec2.y, tmpVec2.z]);
    }
    if (reference) {
      newData = updateRefData(mat);
    }
    ref4 = [demo1, demo2];
    for (m = 0, len2 = ref4.length; m < len2; m++) {
      demo = ref4[m];
      demo.animate(demo.pointsData, {
        ease: 'linear',
        script: {
          0: {
            props: {
              data: random
            }
          },
          .75: {
            props: {
              data: newRandom
            }
          }
        }
      });
      if (reference) {
        demo.animate(demo.refData, {
          ease: 'linear',
          script: {
            0: {
              props: {
                data: refData
              }
            },
            .75: {
              props: {
                data: newData
              }
            }
          }
        });
      }
    }
    random = newRandom;
    if (reference) {
      refData = newData;
    }
    if (iter === 1) {
      document.getElementById('mult-factor').innerText = 'Random vectors multiplied by';
    }
    return katex.render((BName + "^{" + iter + "} ") + ("\\quad\\text{resp.}\\quad " + AName + "^{" + iter + "}"), document.getElementById('An-here'));
  };
  params.Iterate = function() {
    if (!params.Enable) {
      return;
    }
    iteration++;
    return iterate(tB, iteration);
  };
  params.UnIterate = function() {
    if (!params.Enable) {
      return;
    }
    iteration--;
    return iterate(tBinv, iteration);
  };
  folder.add(params, 'Enable').onFinishChange(function(val) {
    dynamicsMode = val ? 'on' : 'off';
    resetMode();
    return updateCaption();
  });
  folder.add(params, 'Reset');
  folder.add(params, 'Iterate');
  folder.add(params, 'UnIterate');
}

window.demo1 = new (size === 3 ? Demo : Demo2D)({
  mathbox: {
    element: document.getElementById("mathbox1")
  }
}, function() {
  var clipCube, diff, labeled, onDrag, r, snapThreshold, snapped, subspace1, subspace2, subspace3, subspaces, tmpVec, view;
  window.mathbox1 = this.mathbox;
  this.range = 5;
  if (this.urlParams.range1 != null) {
    this.range = parseFloat(this.urlParams.range1);
  }
  r = this.range;
  view = this.view({
    name: 'view1',
    viewRange: [[-r, r], [-r, r], [-r, r]].slice(0, size),
    axes: false,
    grid: false
  });
  labeled = this.labeledVectors(view, {
    vectors: [vectorIn1, vectorOut1, e1, e2, e3].slice(0, size + 2),
    colors: colors,
    labels: ['[x]_B', BName + '[x]_B', 'e1', 'e2', 'e3'].slice(0, size + 2),
    live: true,
    zeroPoints: dynamicsMode === 'disabled',
    zeroThreshold: 0.3,
    vectorOpts: {
      zIndex: 2
    },
    labelOpts: {
      zIndex: 3
    },
    zeroOpts: {
      zIndex: 3
    }
  });
  if (dynamicsMode !== 'disabled') {
    makeRandom = (function(_this) {
      return function() {
        var col, i, k, l, len, len1, m, n, results, results1, sign1, sign2, vec, x, θ;
        for (k = 0, len = random.length; k < len; k++) {
          vec = random[k];
          vec[0] = Math.random() * _this.range * 2 - _this.range;
          vec[1] = Math.random() * _this.range * 2 - _this.range;
          if (size === 3) {
            vec[2] = Math.random() * _this.range * 2 - _this.range;
          }
        }
        for (l = 0, len1 = randomColors.length; l < len1; l++) {
          col = randomColors[l];
          col[0] = Math.random() * .5 + .5;
          col[1] = Math.random() * .5 + .5;
          col[2] = Math.random() * .5 + .5;
        }
        switch (reference) {
          case 'circle':
            results = [];
            for (i = m = 0; m < 5; i = ++m) {
              θ = Math.random() * 2 * π;
              random[i][0] = Math.cos(θ);
              results.push(random[i][1] = Math.sin(θ));
            }
            return results;
            break;
          case 'hyperbola':
            results1 = [];
            for (i = n = 0; n < 5; i = ++n) {
              x = Math.random() * (_this.range - 1 / _this.range) + 1 / _this.range;
              sign1 = Math.random() > 0.5 ? 1 : -1;
              sign2 = Math.random() > 0.5 ? 1 : -1;
              random[i][0] = sign1 * x;
              results1.push(random[i][1] = sign2 / x);
            }
            return results1;
        }
      };
    })(this);
    makeRandom();
    view.array({
      channels: 4,
      width: randomColors.length,
      data: randomColors
    });
    this.pointsData = view.array({
      channels: 3,
      width: random.length,
      data: random
    });
    this.points = view.point({
      colors: "<<",
      color: "white",
      size: 20,
      zIndex: 3
    });
    if (reference) {
      this.refData = view.array({
        channels: 3,
        width: refData.length,
        data: refData,
        items: referenceItems,
        live: true
      });
      this.reference = view.line({
        color: "rgb(0, 80, 255)",
        width: 4,
        opacity: .75,
        zBias: 2,
        closed: true
      });
    }
  }
  clipCube = this.clipCube(view, {
    draw: true,
    hilite: size === 3,
    color: new THREE.Color(.75, .75, .75)
  });
  clipCube.clipped.area({
    width: 11,
    height: 11,
    channels: size,
    rangeX: [-r, r],
    rangeY: [-r, r]
  }).surface({
    color: "white",
    opacity: 0.5,
    lineX: true,
    lineY: true,
    fill: false,
    zBias: 0
  }).array({
    channels: 4,
    width: 2,
    items: size,
    data: [[colors[2], colors[3], colors[4]].slice(0, size), [colors[2], colors[3], colors[4]].slice(0, size)]
  }).array({
    width: 2,
    items: size,
    channels: size,
    data: size === 2 ? [[-r, 0], [0, -r], [r, 0], [0, r]] : [[-r, 0, 0], [0, -r, 0], [0, 0, -r], [r, 0, 0], [0, r, 0], [0, 0, r]]
  }).line({
    color: "white",
    colors: "<<",
    width: 3,
    opacity: 1,
    zBias: 1
  });
  tmpVec = new THREE.Vector3();
  computeOut = (function(_this) {
    return function() {
      tmpVec.set.apply(tmpVec, vectorIn1).applyMatrix3(tB);
      vectorOut1[0] = tmpVec.x;
      vectorOut1[1] = tmpVec.y;
      vectorOut1[2] = tmpVec.z;
      tmpVec.applyMatrix3(tC);
      vectorOut2[0] = tmpVec.x;
      vectorOut2[1] = tmpVec.y;
      vectorOut2[2] = tmpVec.z;
      tmpVec.set.apply(tmpVec, vectorIn1).applyMatrix3(tC);
      vectorIn2[0] = tmpVec.x;
      vectorIn2[1] = tmpVec.y;
      vectorIn2[2] = tmpVec.z;
      return updateCaption();
    };
  })(this);
  snapThreshold = 1.0 * this.range / 10.0;
  snapped = new THREE.Vector3();
  diff = new THREE.Vector3();
  subspace1 = this.subspace({
    vectors: [e1]
  });
  subspace2 = this.subspace({
    vectors: [e2]
  });
  subspace3 = this.subspace({
    vectors: [e3]
  });
  subspaces = [subspace1, subspace2, subspace3];
  onDrag = (function(_this) {
    return function(vec) {
      var k, len, results, subspace;
      if (!snap) {
        return;
      }
      results = [];
      for (k = 0, len = subspaces.length; k < len; k++) {
        subspace = subspaces[k];
        subspace.project(vec, snapped);
        diff.copy(vec).sub(snapped);
        if (diff.lengthSq() <= snapThreshold) {
          results.push(vec.copy(snapped));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };
  })(this);
  this.draggable(view, {
    points: [vectorIn1],
    onDrag: onDrag,
    postDrag: computeOut
  });
  return resetMode = (function(_this) {
    return function() {
      var col, demo, eq1Elt, eq2Elt, hexColor, k, l, len, len1, len2, m, matsElt, ref3, ref4, results, results1, str;
      if (dynamicsMode === 'on') {
        updateCaption = function() {};
        str = '<p class="dots">';
        for (k = 0, len = randomColors.length; k < len; k++) {
          col = randomColors[k];
          hexColor = "#" + new THREE.Color(col[0], col[1], col[2]).getHexString();
          str += "<span style=\"color:" + hexColor + "\">&#x25cf;</span>";
        }
        str += '</p>';
        document.getElementsByClassName('overlay-text')[0].innerHTML = str + '<p id="mult-factor">Original random vectors</p>\n<p class="matrix-powers">\n    <span id="An-here"></span>\n</p>';
        ref3 = [demo1, demo2];
        results = [];
        for (l = 0, len1 = ref3.length; l < len1; l++) {
          demo = ref3[l];
          demo.points.set('visible', true);
          if (reference) {
            demo.reference.set('visible', true);
          }
          results.push(demo.mathbox.select('.labeled').set('visible', false));
        }
        return results;
      } else {
        document.getElementsByClassName('overlay-text')[0].innerHTML = '<p><span id="mats-here"></span></p>\n<p><span id="eq1-here"></span> (B-coordinates)</p>\n<p><span id="eq2-here"></span></p>';
        matsElt = document.getElementById('mats-here');
        eq1Elt = document.getElementById('eq1-here');
        eq2Elt = document.getElementById('eq2-here');
        str = _this.texMatrix(A, {
          rows: size,
          cols: size
        });
        str += '=';
        str += _this.texMatrix(C, {
          rows: size,
          cols: size
        });
        str += _this.texMatrix(B, {
          rows: size,
          cols: size
        });
        str += _this.texMatrix(Cinv, {
          rows: size,
          cols: size
        });
        katex.render(str, matsElt);
        updateCaption = function() {
          str = _this.texMatrix(B, {
            rows: size,
            cols: size
          });
          str += _this.texVector(vectorIn1, {
            dim: size,
            color: "#ffff00"
          });
          str += '=';
          str += _this.texVector(vectorOut1, {
            dim: size,
            color: "#888800"
          });
          katex.render(str, eq1Elt);
          str = _this.texMatrix(A, {
            rows: size,
            cols: size
          });
          str += _this.texVector(vectorIn2, {
            dim: size,
            color: "#ff00ff"
          });
          str += '=';
          str += _this.texVector(vectorOut2, {
            dim: size,
            color: "#880088"
          });
          return katex.render(str, eq2Elt);
        };
        if (dynamicsMode !== 'disabled') {
          ref4 = [demo1, demo2];
          results1 = [];
          for (m = 0, len2 = ref4.length; m < len2; m++) {
            demo = ref4[m];
            demo.points.set('visible', false);
            if (reference) {
              demo.reference.set('visible', false);
            }
            results1.push(demo.mathbox.select('.labeled').set('visible', true));
          }
          return results1;
        }
      }
    };
  })(this);
});

window.demo2 = new (size === 3 ? Demo : Demo2D)({
  mathbox: {
    element: document.getElementById("mathbox2")
  }
}, function() {
  var clipCube, colors2, computeIn, diff, labeled, onDrag, r, r2, snapThreshold, snapped, subspace1, subspace2, subspace3, subspaces, tmpVec, view;
  window.mathbox2 = this.mathbox;
  this.range = 5;
  if (this.urlParams.range2 != null) {
    this.range = parseFloat(this.urlParams.range2);
  }
  r = this.range;
  view = this.view({
    name: 'view2',
    viewRange: [[-r, r], [-r, r], [-r, r]].slice(0, size),
    axes: false,
    grid: false
  });
  colors2 = colors.slice();
  colors2[0] = [1, 0, 1, 1];
  colors2[1] = [.7, 0, .7, .7];
  labeled = this.labeledVectors(view, {
    vectors: [vectorIn2, vectorOut2, Ce1, Ce2, Ce3].slice(0, size + 2),
    colors: colors2,
    labels: ['x', AName + 'x'].concat(labels).slice(0, size + 2),
    live: true,
    zeroPoints: dynamicsMode === 'disabled',
    zeroThreshold: 0.3,
    vectorOpts: {
      zIndex: 2
    },
    labelOpts: {
      zIndex: 3
    },
    zeroOpts: {
      zIndex: 3
    }
  });
  clipCube = this.clipCube(view, {
    draw: true,
    hilite: size === 3,
    color: new THREE.Color(.75, .75, .75)
  });
  this.transformed = clipCube.clipped.transform({
    matrix: [C[0][0], C[1][0], C[2][0], 0, C[0][1], C[1][1], C[2][1], 0, C[0][2], C[1][2], C[2][2], 0, 0, 0, 0, 1]
  });
  r2 = demo1.range * 5;
  this.transformed.area({
    width: 51,
    height: 51,
    channels: size,
    rangeX: [-r2, r2],
    rangeY: [-r2, r2]
  }).surface({
    color: "white",
    opacity: 0.5,
    lineX: true,
    lineY: true,
    fill: false,
    zBias: 0
  }).array({
    channels: 4,
    width: 2,
    items: size,
    data: [[colors[2], colors[3], colors[4]].slice(0, size), [colors[2], colors[3], colors[4]].slice(0, size)]
  }).array({
    width: 2,
    items: size,
    channels: size,
    data: size === 2 ? [[-r2, 0], [0, -r2], [r2, 0], [0, r2]] : [[-r2, 0, 0], [0, -r2, 0], [0, 0, -r2], [r2, 0, 0], [0, r2, 0], [0, 0, r2]]
  }).line({
    color: "white",
    colors: "<<",
    width: 3,
    opacity: 1,
    zBias: 1
  });
  if (dynamicsMode !== 'disabled') {
    this.transformed.array({
      channels: 4,
      width: randomColors.length,
      data: randomColors
    });
    this.pointsData = this.transformed.array({
      channels: 3,
      width: random.length,
      data: random
    });
    this.points = this.transformed.point({
      colors: "<<",
      color: "white",
      size: 20,
      zIndex: 3
    });
    if (reference) {
      this.refData = this.transformed.array({
        channels: 3,
        width: refData.length,
        data: refData,
        items: referenceItems,
        live: true
      });
      this.reference = this.transformed.line({
        color: "rgb(0, 80, 255)",
        width: 4,
        opacity: .75,
        zBias: 2,
        closed: true
      });
    }
  }
  tmpVec = new THREE.Vector3();
  computeIn = function() {
    tmpVec.set.apply(tmpVec, vectorIn2).applyMatrix3(tCinv);
    vectorIn1[0] = tmpVec.x;
    vectorIn1[1] = tmpVec.y;
    vectorIn1[2] = tmpVec.z;
    tmpVec.applyMatrix3(tB);
    vectorOut1[0] = tmpVec.x;
    vectorOut1[1] = tmpVec.y;
    vectorOut1[2] = tmpVec.z;
    tmpVec.applyMatrix3(tC);
    vectorOut2[0] = tmpVec.x;
    vectorOut2[1] = tmpVec.y;
    vectorOut2[2] = tmpVec.z;
    return updateCaption();
  };
  snapThreshold = 1.0 * this.range / 10.0;
  snapped = new THREE.Vector3();
  diff = new THREE.Vector3();
  subspace1 = this.subspace({
    vectors: [Ce1]
  });
  subspace2 = this.subspace({
    vectors: [Ce2]
  });
  subspace3 = this.subspace({
    vectors: [Ce3]
  });
  subspaces = [subspace1, subspace2, subspace3];
  onDrag = (function(_this) {
    return function(vec) {
      var k, len, results, subspace;
      results = [];
      for (k = 0, len = subspaces.length; k < len; k++) {
        subspace = subspaces[k];
        subspace.project(vec, snapped);
        diff.copy(vec).sub(snapped);
        if (diff.lengthSq() <= snapThreshold) {
          results.push(vec.copy(snapped));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };
  })(this);
  return this.draggable(view, {
    points: [vectorIn2],
    onDrag: onDrag,
    postDrag: computeIn
  });
});

groupControls(demo1, demo2);

resetMode();

computeOut();


        });
    </script>
</body>
</html>

