<!DOCTYPE html> <!-- -*- coffee -*-
-->
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="initial-scale=1, maximum-scale=1">
  <title>Cover</title>

  <link rel="stylesheet" href="mathbox/mathbox.css">

  <style>
  #content {
      width:        80%;
      margin-left:  auto;
      margin-right: auto;
  }
  #mathbox-container {
      width:       100%;
      height:      0;
      padding-top: 100%;
      overflow:    hidden;
      position:    relative;
  }
  #mathbox {
      position: absolute;
      top:      0;
      left:     0;
      width:    100%;
      height:   100%;
  }
  </style>
</head>
<body>
    <div id="content">
        <div id="mathbox-container">
            <div id="mathbox">
            </div>
        </div>
    </div>

  <script src="mathbox/mathbox-bundle.js?version=3"></script>
  <script src="lib/domready.js"></script>

  <script type="application/glsl" id="rotate-shader">

#define M_PI 3.1415926535897932384626433832795

uniform float deltaAngle;
uniform float scale;
uniform float time;

vec4 getTimingsSample(vec4 xyzw);
vec4 getPointSample(vec4 xyzw);

float easeInOutSine(float pos) {
    return 0.5 * (1.0 - cos(M_PI * pos));
}

vec4 rotate(vec4 xyzw) {
    vec4 timings = getTimingsSample(xyzw);
    vec4 point = getPointSample(xyzw);
    float start = timings.x;
    float duration = timings.y;
    if(time < start) {
        return vec4(point.xy, 0.0, 0.0);
    }
    float pos = min((time - start) / duration, 1.0);
    pos = easeInOutSine(pos);
    float c = cos(deltaAngle * pos);
    float s = sin(deltaAngle * pos);
    point.xy = vec2(point.x * c - point.y * s, point.x * s + point.y * c)
        * pow(scale, pos);
    return vec4(point.xy, 0.0, 0.0);
}

  </script>

  <script type="application/glsl" id="color-shader">

#define M_PI 3.1415926535897932384626433832795

uniform float time;

vec4 getTimingsSample(vec4 xyzw);
vec4 getColorSample(vec4 xyzw);

float easeInOutSine(float pos) {
    return 0.5 * (1.0 - cos(M_PI * pos));
}

vec3 hsv2rgb(vec3 c) {
  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

#define TRANSITION 0.2

vec4 getColor(vec4 xyzw) {
    vec4 color = getColorSample(xyzw);
    vec4 timings = getTimingsSample(xyzw);
    float start = timings.x;
    float duration = timings.y;
    float pos, ease;
    pos = max(0.0, min(1.0, (time - start) / duration));
    if(pos < TRANSITION) {
        ease = easeInOutSine(pos / TRANSITION);
        color.w *= ease * 0.6 + 0.4;
        color.y *= ease * 0.6 + 0.4;
    }
    else if(pos > 1.0 - TRANSITION) {
        ease = easeInOutSine((1.0 - pos) / TRANSITION);
        color.w *= ease * 0.6 + 0.4;
        color.y *= ease * 0.6 + 0.4;
    }
    return vec4(hsv2rgb(color.xyz), color.w);
}

  </script>

  <script type="application/glsl" id="size-shader">

#define M_PI 3.1415926535897932384626433832795

uniform float time;

vec4 getTimingsSample(vec4 xyzw);

float easeInOutSine(float pos) {
    return 0.5 * (1.0 - cos(M_PI * pos));
}

#define TRANSITION 0.2
#define SMALL 5.0
#define BIG 7.0

vec4 getSize(vec4 xyzw) {
    vec4 timings = getTimingsSample(xyzw);
    float start = timings.x;
    float duration = timings.y;
    float pos, ease, size = BIG;
    pos = max(0.0, min(1.0, (time - start) / duration));
    if(pos < TRANSITION) {
        ease = easeInOutSine(pos / TRANSITION);
        size = SMALL * (1.0-ease) + BIG * ease;
    }
    else if(pos > 1.0 - TRANSITION) {
        ease = easeInOutSine((1.0 - pos) / TRANSITION);
        size = SMALL * (1.0-ease) + BIG * ease;
    }
    return vec4(size, 0.0, 0.0, 0.0);
}

  </script>

  <script type="text/javascript">
      "use strict";
      DomReady.ready(function() {

/*
*/

// Generated by CoffeeScript 1.10.0
var Circle, Complex, Dynamics, HSVtoRGB, Spiral, SpiralIn, SpiralOut, colors, curTime, current, delay, discLerp, duration, expLerp, farthest, i, initialized, inv22, k, len1, linLerp, linesDataElt, linesElt, makeCoordMat, mathbox, mode, mult22, myMathBox, numPoints, ortho, points, randElt, randSign, ref, shaderElt, stepMat, three, timings, types, view, view0,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

HSVtoRGB = function(h, s, v) {
  var f, i, p, q, t;
  i = Math.floor(h * 6);
  f = h * 6 - i;
  p = v * (1 - s);
  q = v * (1 - f * s);
  t = v * (1 - (1 - f) * s);
  switch (i % 6) {
    case 0:
      return [v, t, p];
    case 1:
      return [q, v, p];
    case 2:
      return [p, v, t];
    case 3:
      return [p, q, v];
    case 4:
      return [t, p, v];
    case 5:
      return [v, p, q];
  }
};

expLerp = function(a, b) {
  return function(t) {
    return Math.pow(b, t) * Math.pow(a, 1 - t);
  };
};

linLerp = function(a, b) {
  return function(t) {
    return b * t + a * (1 - t);
  };
};

discLerp = function(a, b, n) {
  return function(t) {
    return Math.floor(Math.random() * (n + 1)) * (b - a) / n + a;
  };
};

randElt = function(l) {
  return l[Math.floor(Math.random() * l.length)];
};

randSign = function() {
  return randElt([-1, 1]);
};

mult22 = function(m, v) {
  return [m[0] * v[0] + m[1] * v[1], m[2] * v[0] + m[3] * v[1]];
};

inv22 = function(m) {
  var det;
  det = m[0] * m[3] - m[1] * m[2];
  return [m[3] / det, -m[1] / det, -m[2] / det, m[0] / det];
};

ortho = 1e5;

myMathBox = function(options) {
  var ref, three;
  three = THREE.Bootstrap(options);
  if (!three.fallback) {
    if (!three.Time) {
      three.install('time');
    }
    if (!three.MathBox) {
      three.install(['mathbox']);
    }
  }
  return (ref = three.mathbox) != null ? ref : three;
};

mathbox = window.mathbox = myMathBox({
  plugins: ['core'],
  mathbox: {
    inspect: false,
    splash: false
  },
  camera: {
    near: ortho / 4,
    far: ortho * 4
  },
  element: document.getElementById("mathbox")
});

if (mathbox.fallback) {
  throw "WebGL not supported";
}

three = window.three = mathbox.three;

three.renderer.setClearColor(new THREE.Color(0xffffff), 1.0);

mathbox.camera({
  proxy: false,
  position: [0, 0, ortho],
  lookAt: [0, 0, 0],
  up: [1, 0, 0],
  fov: Math.atan(1 / ortho) * 360 / π
});

mathbox.set('focus', ortho / 1.5);

view0 = mathbox.cartesian({
  range: [[-1, 1], [-1, 1]],
  scale: [1, 1]
});

current = null;

numPoints = 5000;

duration = 3.0;

delay = function(first) {
  var pos, scale;
  scale = numPoints / 1000;
  pos = Math.random() * scale;
  if (first) {
    return pos - 0.5 * scale;
  } else {
    return pos;
  }
};

curTime = 0;

mode = 'spiralIn';

points = [[0, 0, 0, 0]];

stepMat = [];

timings = [[1, 1]];

colors = [[0, 0, 0, 1]].concat((function() {
  var k, ref, results;
  results = [];
  for (k = 0, ref = numPoints; 0 <= ref ? k < ref : k > ref; 0 <= ref ? k++ : k--) {
    results.push([Math.random(), 1, 0.7, 1]);
  }
  return results;
})());

view = null;

farthest = null;

makeCoordMat = function() {
  var coordMat, coordMatInv, corners, distribution, len, transformMat, v1, v2, θ, θoff;
  v1 = [0, 0];
  v2 = [0, 0];
  distribution = linLerp(0.5, 2);
  len = distribution(Math.random());
  θ = Math.random() * 2 * π;
  v1[0] = Math.cos(θ) * len;
  v1[1] = Math.sin(θ) * len;
  θoff = randSign() * linLerp(π / 4, 3 * π / 4)(Math.random());
  len = distribution(Math.random());
  v2[0] = Math.cos(θ + θoff) * len;
  v2[1] = Math.sin(θ + θoff) * len;
  coordMat = [v1[0], v2[0], v1[1], v2[1]];
  coordMatInv = inv22(coordMat);
  corners = [[1, 1], [-1, 1]].map(function(c) {
    return mult22(coordMatInv, c);
  });
  farthest = Math.max.apply(null, corners.map(function(c) {
    return c[0] * c[0] + c[1] * c[1];
  }));
  farthest = Math.sqrt(farthest);
  transformMat = [coordMat[0], coordMat[1], 0, 0, coordMat[2], coordMat[3], 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  if (view) {
    return view.set('matrix', transformMat);
  } else {
    return view = view0.transform({
      matrix: transformMat
    });
  }
};

makeCoordMat();

ref = [1, 2];
for (k = 0, len1 = ref.length; k < len1; k++) {
  i = ref[k];
  view.axis({
    axis: i,
    end: false,
    width: 3,
    size: 5,
    zBias: -1,
    depth: 1,
    color: "black",
    opacity: 0.5,
    range: [-10, 10]
  });
}

initialized = false;

shaderElt = null;

linesElt = null;

linesDataElt = null;

Dynamics = (function() {
  function Dynamics() {
    this.refClosed = bind(this.refClosed, this);
    this.linesParams = bind(this.linesParams, this);
    this.install = bind(this.install, this);
  }

  Dynamics.prototype.install = function() {
    var o, pointsElt, ref1;
    for (i = o = 1, ref1 = numPoints; 1 <= ref1 ? o <= ref1 : o >= ref1; i = 1 <= ref1 ? ++o : --o) {
      this.newPoint(i, true);
      timings[i][0] = curTime + delay(true);
    }
    if (initialized) {
      shaderElt.set(this.shaderParams());
      linesDataElt.set(this.linesParams());
      return linesElt.set("closed", this.refClosed());
    } else {
      view0.array({
        id: "timings",
        channels: 2,
        width: timings.length,
        data: timings,
        live: true
      });
      pointsElt = view.array({
        id: "points-orig",
        channels: 4,
        width: points.length,
        data: points
      });
      shaderElt = pointsElt.shader(this.shaderParams(), {
        time: function(t) {
          return curTime = t;
        }
      });
      shaderElt.resample({
        id: "points"
      });
      view0.array({
        channels: 4,
        width: colors.length,
        data: colors,
        live: false
      }).shader({
        code: "#color-shader",
        sources: ["#timings"]
      }, {
        time: function(t) {
          return t;
        }
      }).resample({
        id: "colors"
      });
      view0.shader({
        code: "#size-shader"
      }, {
        time: function(t) {
          return t;
        }
      }).resample({
        source: "#timings",
        id: "sizes"
      });
      view.point({
        points: "#points",
        color: "white",
        colors: "#colors",
        size: 1,
        sizes: "#sizes",
        zBias: 1,
        zIndex: 2
      });
      linesDataElt = view.array(this.linesParams());
      linesElt = view.line({
        color: "rgb(0, 80, 255)",
        width: 2,
        opacity: 0.75,
        zBias: 0,
        zIndex: 1,
        closed: this.refClosed()
      });
      return initialized = true;
    }
  };

  Dynamics.prototype.linesParams = function() {
    this.reference = this.makeReference();
    return {
      channels: 2,
      width: this.reference.length,
      items: this.reference[0].length,
      data: this.reference,
      live: false
    };
  };

  Dynamics.prototype.refClosed = function() {
    return false;
  };

  return Dynamics;

})();

Complex = (function(superClass) {
  extend(Complex, superClass);

  function Complex() {
    this.shaderParams = bind(this.shaderParams, this);
    this.newPoint = bind(this.newPoint, this);
    Complex.__super__.constructor.apply(this, arguments);
    this.deltaAngle = randSign() * linLerp(π / 6, 5 * π / 6)(Math.random());
    this.scale = this.getScale();
    stepMat = [Math.cos(this.deltaAngle) * this.scale, -Math.sin(this.deltaAngle) * this.scale, Math.sin(this.deltaAngle) * this.scale, Math.cos(this.deltaAngle) * this.scale];
    this.makeDistributions();
  }

  Complex.prototype.newPoint = function(i, first) {
    var distribution, r, θ;
    distribution = first ? this.origDist : this.newDist;
    r = distribution(Math.random());
    θ = Math.random() * 2 * π;
    timings[i] = [0, duration];
    return points[i] = [Math.cos(θ) * r, Math.sin(θ) * r, 0, 0];
  };

  Complex.prototype.shaderParams = function() {
    return {
      code: '#rotate-shader',
      sources: ["#timings"],
      uniforms: {
        deltaAngle: {
          type: 'f',
          value: this.deltaAngle
        },
        scale: {
          type: 'f',
          value: this.scale
        }
      }
    };
  };

  return Complex;

})(Dynamics);

Circle = (function(superClass) {
  extend(Circle, superClass);

  function Circle() {
    this.refClosed = bind(this.refClosed, this);
    this.updatePoint = bind(this.updatePoint, this);
    this.makeReference = bind(this.makeReference, this);
    this.makeDistributions = bind(this.makeDistributions, this);
    this.getScale = bind(this.getScale, this);
    return Circle.__super__.constructor.apply(this, arguments);
  }

  Circle.prototype.getScale = function() {
    return 1;
  };

  Circle.prototype.makeDistributions = function() {
    return this.newDist = this.origDist = linLerp(0.01, farthest);
  };

  Circle.prototype.makeReference = function() {
    var o, ref1, ref2, ref3, ref4, ref5, results, row, s, t, u;
    results = [];
    for (t = o = 0, ref1 = 2 * π, ref2 = π / 72; ref2 > 0 ? o < ref1 : o > ref1; t = o += ref2) {
      row = [];
      for (s = u = ref3 = farthest / 10, ref4 = farthest, ref5 = farthest / 10; ref5 > 0 ? u < ref4 : u > ref4; s = u += ref5) {
        row.push([s * Math.cos(t), s * Math.sin(t)]);
      }
      results.push(row);
    }
    return results;
  };

  Circle.prototype.updatePoint = function(i) {
    return points[i];
  };

  Circle.prototype.refClosed = function() {
    return true;
  };

  return Circle;

})(Complex);

Spiral = (function(superClass) {
  extend(Spiral, superClass);

  function Spiral() {
    this.makeReference = bind(this.makeReference, this);
    return Spiral.__super__.constructor.apply(this, arguments);
  }

  Spiral.prototype.makeReference = function() {
    var j, o, ref1, ref2, ref3, ref4, ref5, results, row, s, t, u;
    results = [];
    for (t = o = ref1 = -10 * π, ref2 = 10 * π, ref3 = π / 72; ref3 > 0 ? o < ref2 : o > ref2; t = o += ref3) {
      s = Math.pow(this.scale, t / this.deltaAngle);
      row = [];
      for (j = u = 0, ref4 = 2 * π, ref5 = π / 4; ref5 > 0 ? u < ref4 : u > ref4; j = u += ref5) {
        row.push([s * Math.cos(t + j), s * Math.sin(t + j)]);
      }
      results.push(row);
    }
    return results;
  };

  return Spiral;

})(Complex);

SpiralIn = (function(superClass) {
  extend(SpiralIn, superClass);

  function SpiralIn() {
    this.updatePoint = bind(this.updatePoint, this);
    this.makeDistributions = bind(this.makeDistributions, this);
    return SpiralIn.__super__.constructor.apply(this, arguments);
  }

  SpiralIn.prototype.getScale = function() {
    return linLerp(0.3, 0.8)(Math.random());
  };

  SpiralIn.prototype.makeDistributions = function() {
    var distance, distances;
    this.close = 0.01;
    this.medium = farthest;
    this.far = farthest / this.scale;
    switch (randElt(['cont', 'disc'])) {
      case 'cont':
        this.origDist = expLerp(this.close, this.far);
        return this.newDist = expLerp(this.medium, this.far);
      case 'disc':
        distances = [];
        distance = this.far;
        while (distance > this.close) {
          distances.push(distance);
          distance *= this.scale;
        }
        this.origDist = function(t) {
          return distances[Math.floor(t * distances.length)];
        };
        return this.newDist = (function(_this) {
          return function(t) {
            return _this.far;
          };
        })(this);
    }
  };

  SpiralIn.prototype.updatePoint = function(i) {
    var point;
    point = points[i];
    if (point[0] * point[0] + point[1] * point[1] < this.close * this.close) {
      this.newPoint(i);
    }
    return points[i];
  };

  return SpiralIn;

})(Spiral);

SpiralOut = (function(superClass) {
  extend(SpiralOut, superClass);

  function SpiralOut() {
    this.updatePoint = bind(this.updatePoint, this);
    this.makeDistributions = bind(this.makeDistributions, this);
    return SpiralOut.__super__.constructor.apply(this, arguments);
  }

  SpiralOut.prototype.getScale = function() {
    return linLerp(1 / 0.8, 1 / 0.3)(Math.random());
  };

  SpiralOut.prototype.makeDistributions = function() {
    var distance, distances;
    this.veryClose = 0.01 / this.scale;
    this.close = 0.01;
    this.medium = farthest;
    switch (randElt(['cont', 'disc'])) {
      case 'cont':
        this.origDist = expLerp(this.veryClose, this.medium);
        return this.newDist = expLerp(this.veryClose, this.close);
      case 'disc':
        distances = [];
        distance = this.veryClose;
        while (distance < this.medium) {
          distances.push(distance);
          distance *= this.scale;
        }
        this.origDist = function(t) {
          return distances[Math.floor(t * distances.length)];
        };
        return this.newDist = (function(_this) {
          return function(t) {
            return _this.veryClose;
          };
        })(this);
    }
  };

  SpiralOut.prototype.updatePoint = function(i) {
    var point;
    point = points[i];
    if (point[0] * point[0] + point[1] * point[1] > this.medium * this.medium) {
      this.newPoint(i);
    }
    return points[i];
  };

  return SpiralOut;

})(Spiral);

types = [Circle, SpiralIn, SpiralOut];

current = new Circle();

current.install();

setInterval(function() {
  var type;
  makeCoordMat();
  type = randElt(types);
  current = new type();
  return current.install();
}, 5000);

setInterval(function() {
  var end, len2, o, point, ref1;
  for (i = o = 0, len2 = points.length; o < len2; i = ++o) {
    point = points[i];
    if (i === 0) {
      continue;
    }
    end = timings[i][0] + timings[i][1];
    if (end < curTime) {
      ref1 = mult22(stepMat, point), point[0] = ref1[0], point[1] = ref1[1];
      point = current.updatePoint(i);
      timings[i][0] = curTime + delay();
    }
  }
  return null;
}, 100);

/*
*/
        });
  </script>
</body>
</html>
<!--

-->
