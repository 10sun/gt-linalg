<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Shearing game</title>
  <script src="../build/mathbox-bundle.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.js"></script>
  <script src="matrices.js"></script>
  <link rel="stylesheet" href="../build/mathbox.css">
  <meta name="viewport" content="initial-scale=1, maximum-scale=1">
</head>
<body>
    <header>
      <h1>Shearing game</h1>
      <section>
	<h2>Controls</h2>
	<dl id="controls" >
	</dl>
      </section>
      <section>
	  <h2>Objective</h2>
	  <p>Transform the parallelogram to a square.</p>
      </section>
    </header>


    <script>
     var mathbox = mathBox({
	 plugins: ['core', 'controls', 'cursor', 'mathbox'],
	 controls: {
             // Orbit controls, i.e. Euler angles, with gimbal lock
             klass: THREE.OrbitControls,

             // Trackball controls, i.e. Free quaternion rotation
             //klass: THREE.TrackballControls,
	 },
     });
     if (mathbox.fallback) throw "WebGL not supported"

     /* Makes the background white */
     var three = mathbox.three;
     three.renderer.setClearColor(new THREE.Color(0xFFFFFF), 1.0);


     // Place camera
     var camera =
	 mathbox
	     .camera({
		 proxy: false,
		 position: [0, 0, 3],
	     });

     // 2D cartesian
     var view =
	 mathbox
	     .cartesian({
		 range: [[0, 1], [0, 1]],
		 scale: [1, 1],
	     });


     // Calibrate focus distance for units
     mathbox.set('focus', 3);


     // The initial matrix
     var mat = new Matrix([[2, 1], [1, 1]]);

     // Initialize available ransformations
     var transformations = [
	 Matrix.shear(-1, 'H'),
	 Matrix.shear(1, 'H'),
	 Matrix.shear(1, 'V'),
	 Matrix.shear(-1, 'V')
     ];

     // Generating HTML list describing the controls
     var controls = document.getElementById("controls");
     for(var i = 0; i < transformations.length; i++) {
	 var tr = transformations[i];

	 var dt = document.createElement('dt');
	 dt.innerHTML = `${tr.keycode}`;
	 controls.appendChild(dt);

	 var dd = document.createElement('dd');
	 var span1 = document.createElement('span');
	 span1.innerHTML = tr.description + '. Matrix: ';
	 var span2 = document.createElement('span');
	 tr.katex(span2);
	 dd.appendChild(span1);
	 dd.appendChild(span2);
	 controls.appendChild(dd);
     }

     // Creating data grid.
     var n = 20;
     view.area({
	 id: "grid",
	 axes: [1, 2],
	 width: n,
	 height: n,
	 channels: 2,
	 expr: function (emit, x, y, i, j, time) {
	     var vec = mat.multiply_vec(x,y);
	     emit(vec[0], vec[1]);
	 },
     });

     view.surface({
	 /* shaded: true,*/
	 points: '<',
	 fill: false,
	 lineX: true,
	 lineY: true,
	 /* width: 2,*/
	 color: "purple",
     });

     // TODO: draw origin.

     /* Applying transformations on keypresses. */
     document.onkeydown = function(e) {
	 var code = e.keyCode;

	 for(var i = 0; i < transformations.length; i++) {
	     var tr = transformations[i];
	     if (code == tr.keycode) {
		 mat = mul(tr, mat);
	     }
	 }
     };

     document.onkeyup = function() {
	 if (mat.is_identity()) {
	     alert('You won!');
	 }
     };
    </script>

</body>
</html>
