<!DOCTYPE html> <!-- -*- html -*- -->
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="initial-scale=1, maximum-scale=1">
  <title>Matrix Dynamics</title>
  <link rel="shortcut icon" href="img/gatech.gif"/>

  
      <link rel="stylesheet" href="css/demo.css?vers=2759ff">
  

  <style>
      

html, body {
    margin:           0;
    height:           100%;
    background-color: white;
    overflow-x:       hidden;
}
#mathbox {
    width:       100%;
    height:      100%;
}
.espace-1 {
    color: var(--palette-green);
}
.espace-2 {
    color: var(--palette-violet);
}
.espace-3 {
    color: var(--palette-brown);
}
.overlay-text {
    z-index: 1;
}
#mult-here.hidden {
    display: none;
}

  </style>

</head>
<body>
    

<div id="mathbox">
</div>


    
    
        <script src="js/demo.js?vers=39ead6"></script>
    
    <script src="js/dynamics.js?vers=288fda"></script>


    <script type="text/javascript">
        "use strict";
        DomReady.ready(function() {

        // Generated by CoffeeScript 1.12.6
var Imλ, Reλ, a, almostZero, axisColors, b, basis1, basis2, c, d, determinant, discriminant, duration, eigenStr, eigenStrs, eigenz, i, len, matName, matrix, normalize, opts, ref, ref1, ref2, ref3, row, size, str, swap, testMatrices, trace, type, v, v1, v1p, v2, v2p, v3, vecColor, δ, λ, λ1, λ2;

matrix = urlParams.get('mat', 'matrix', [[1 / 2, 1 / 2], [-1 / 2, 1 / 2]]);

duration = urlParams.get('duration', 'float', 2.5);

matName = (ref = urlParams.matname) != null ? ref : 'A';

size = urlParams.eigenz != null ? 3 : 2;

eigenz = urlParams.get('eigenz', 'float', 1);

v1 = urlParams.get('v1', 'float[]', [1, 0, 0]);

v2 = urlParams.get('v2', 'float[]', [0, 1, 0]);

v3 = urlParams.get('v3', 'float[]', [0, 0, 1]);

testMatrices = {
  Shear: [[2 / 3, 1 / 3], [-1 / 3, 4 / 3]],
  ScaleOutShear: [[5 / 3, 1 / 3], [-1 / 3, 7 / 3]],
  ScaleInShear: [[1 / 3, 1 / 6], [-1 / 6, 2 / 3]],
  Circle: [[1 / 3, -1 / 3], [5 / 6, 2 / 3]],
  SpiralIn: [[1 / 3, -1 / 3], [5 / 6, 2 / 3]],
  SpiralOut: [[2 / 3, -2 / 3], [5 / 3, 4 / 3]],
  AttractLine: [[5 / 6, 1 / 6], [1 / 3, 2 / 3]],
  RepelLine: [[4 / 3, -1 / 3], [-2 / 3, 5 / 3]],
  Attract: [[7 / 18, -1 / 18], [-1 / 9, 4 / 9]],
  Repel: [[8 / 3, 1 / 3], [2 / 3, 7 / 3]],
  Hyperbolas: [[8 / 9, -5 / 9], [-10 / 9, 13 / 9]]
};

ref1 = testMatrices.Circle;
for (i = 0, len = ref1.length; i < len; i++) {
  row = ref1[i];
  row[0] *= Math.sqrt(2);
  row[1] *= Math.sqrt(2);
}

if (urlParams.testmat != null) {
  matrix = testMatrices[urlParams.testmat];
}

(ref2 = matrix[0], a = ref2[0], b = ref2[1]), (ref3 = matrix[1], c = ref3[0], d = ref3[1]);

trace = a + d;

determinant = a * d - b * c;

discriminant = trace * trace - 4 * determinant;

basis1 = [];

basis2 = [];

type = null;

opts = {};

axisColors = [new Color("green").arr(1), new Color("violet").arr(1), new Color("brown").arr(1)];

eigenStrs = [];

almostZero = function(x) {
  return Math.abs(x) < 1e-5;
};

normalize = function(b) {
  var n;
  n = Math.sqrt(b[0] * b[0] + b[1] * b[1]);
  return [b[0] / n, b[1] / n];
};

if (almostZero(determinant)) {
  throw "Can't handle non-invertible matrix";
}

if (almostZero(discriminant)) {
  λ = trace / 2;
  if (λ < 0) {
    throw "Can't handle negative real eigenvalues";
  }
  if (almostZero(b) && almostZero(c)) {
    basis1 = [1, 0];
    basis2 = [0, 1];
    axisColors[1] = axisColors[0];
    eigenStrs.push("The whole plane is the <span class=\"espace-1\">" + ((λ.toFixed(2)) + "-eigenspace.</span>"));
    type = λ > 1 ? dynamics.Repel : dynamics.Attract;
    opts = {
      λ1: λ,
      λ2: λ
    };
  } else {
    if (almostZero(b)) {
      basis1 = normalize([λ - d, c]);
    } else {
      basis1 = normalize([b, λ - a]);
    }
    basis2 = [basis1[1], -basis1[0]];
    axisColors[1] = [0.5, 0.5, 0.5, 0.3];
    eigenStrs.push("This is the <span class=\"espace-1\">" + ((λ.toFixed(2)) + "-eigenspace.</span>"));
    v = [(a - λ) * basis2[0] + b * basis2[1], c * basis2[0] + (d - λ) * basis2[1]];
    if (almostZero(basis1[0])) {
      opts.translate = v[1] / (λ * basis1[1]);
    } else {
      opts.translate = v[0] / (λ * basis1[0]);
    }
    if (almostZero(λ - 1)) {
      type = dynamics.Shear;
    } else {
      if (λ > 1) {
        type = dynamics.ScaleOutShear;
      } else {
        type = dynamics.ScaleInShear;
      }
      opts.scale = λ;
    }
  }
} else if (discriminant < 0) {
  Reλ = trace / 2;
  Imλ = Math.sqrt(-discriminant) / 2;
  basis1 = [b / Imλ, (Reλ - a) / Imλ];
  basis2 = [0, 1];
  axisColors[0] = [0.5, 0.5, 0.5, 0.3];
  axisColors[1] = [0.5, 0.5, 0.5, 0.3];
  str = 'This matrix has complex eigenvalues ';
  str += katex.renderToString("\\lambda = " + (Reλ.toFixed(2)) + "\\pm " + (Imλ.toFixed(2)) + "i");
  str += '.';
  eigenStrs.push(str);
  opts = {
    θ: Math.atan2(-Imλ, Reλ),
    scale: Math.sqrt(determinant),
    dist: 'cont'
  };
  if (almostZero(opts.scale - 1)) {
    type = dynamics.Circle;
  } else {
    if (opts.scale > 1) {
      type = dynamics.SpiralOut;
    } else {
      type = dynamics.SpiralIn;
    }
  }
} else if (discriminant > 0) {
  δ = Math.sqrt(discriminant);
  λ1 = (trace - δ) / 2;
  λ2 = (trace + δ) / 2;
  if (almostZero(b)) {
    if (almostZero(c)) {
      if (almostZero(a - λ1)) {
        basis1 = [1, 0];
        basis2 = [0, 1];
      } else {
        basis2 = [1, 0];
        basis1 = [0, 1];
      }
    } else {
      basis1 = normalize([λ1 - d, c]);
      basis2 = normalize([λ2 - d, c]);
    }
  } else {
    basis1 = normalize([b, λ1 - a]);
    basis2 = normalize([b, λ2 - a]);
  }
  if (λ1 < 0 || λ2 < 0) {
    throw "Can't handle negative real eigenvalues";
  }
  opts = {
    λ1: λ1,
    λ2: λ2
  };
  swap = function() {
    var ref4, ref5;
    ref4 = [opts.λ1, opts.λ2], opts.λ2 = ref4[0], opts.λ1 = ref4[1];
    return ref5 = [basis1, basis2], basis2 = ref5[0], basis1 = ref5[1], ref5;
  };
  if (almostZero(λ1 - 1)) {
    type = dynamics.RepelLine;
  } else if (almostZero(λ2 - 1)) {
    type = dynamics.AttractLine;
    swap();
  } else if (λ1 < 1 && λ2 < 1) {
    type = dynamics.Attract;
    swap();
  } else if (λ1 < 1 && λ2 > 1) {
    type = dynamics.Hyperbolas;
  } else if (λ1 > 1 && λ2 > 1) {
    type = dynamics.Repel;
  }
  eigenStrs.push("This is the <span class=\"espace-1\">" + ((opts.λ1.toFixed(2)) + "-eigenspace.</span>"));
  eigenStrs.push("This is the <span class=\"espace-2\">" + ((opts.λ2.toFixed(2)) + "-eigenspace.</span>"));
}

v1p = [v1[0] * basis1[0] + v2[0] * basis1[1], v1[1] * basis1[0] + v2[1] * basis1[1], v1[2] * basis1[0] + v2[2] * basis1[1]];

v2p = [v1[0] * basis2[0] + v2[0] * basis2[1], v1[1] * basis2[0] + v2[1] * basis2[1], v1[2] * basis2[0] + v2[2] * basis2[1]];

v1 = v1p;

v2 = v2p;

if (size === 3) {
  eigenStrs.push("This is the <span class=\"espace-3\">" + ((eigenz.toFixed(2)) + "-eigenspace.</span>"));
}

eigenStr = eigenStrs.join("<br>");

vecColor = new Color("red");

window.demo = new (size === 3 ? Demo : Demo2D)({
  mathbox: {
    element: document.getElementById("mathbox"),
    size: {
      aspect: 1
    }
  },
  vertical: 1.1
}, function() {
  var computeOut, computePath, controller, diff, displayMat, drag, gui, matElt, multElt, params, path, snap, snapped, subspace, te, togglePath, toggleVector, updateCaption, vectorIn, vectorOut, view, viewT;
  window.controller = controller = new dynamics.Controller(this.mathbox, {
    continuous: false,
    flow: urlParams.get('flow', 'bool', false),
    axisOpts: {
      width: size === 3 ? 5 : 3,
      opacity: 1.0
    },
    axisColors: axisColors,
    refColor: new Color("blue").arr(),
    duration: duration,
    is3D: size === 3,
    clipCube: (function(_this) {
      return function(view) {
        return _this.clipCube(view, {
          draw: size === 3,
          hilite: false
        });
      };
    })(this)
  });
  if (size === 2) {
    controller.installCoords(v1, v2);
  } else {
    controller.installCoords(v1, v2, v3);
    opts.scaleZ = eigenz;
  }
  controller.install(type, opts);
  console.log("Type: ", controller.current.descr());
  console.log("Opts: ", opts);
  vectorIn = [.5, 0, 0];
  vectorOut = [0, 0, 0];
  te = controller.matrixOrigCoords.elements;
  if (size === 2) {
    displayMat = [[te[0], te[1]], [te[4], te[5]]];
  } else if (size === 3) {
    displayMat = [[te[0], te[1], te[2]], [te[4], te[5], te[6]], [te[8], te[9], te[10]]];
  }
  str = '<p><span id="mat-here"></span>' + '<span id="mult-here"></span></p>';
  str += eigenStr;
  this.caption(str);
  matElt = document.getElementById('mat-here');
  multElt = document.getElementById('mult-here');
  str = (matName + " = ") + this.texMatrix(displayMat);
  katex.render(str, matElt);
  updateCaption = (function(_this) {
    return function() {
      var vin, vout, x;
      vin = vectorIn.slice(0, size);
      controller.coordMatInv.applyToVector3Array(vin);
      vout = vectorOut.slice(0, size);
      str = '\\qquad ' + matName + _this.texVector((function() {
        var j, len1, results;
        results = [];
        for (j = 0, len1 = vin.length; j < len1; j++) {
          x = vin[j];
          results.push(x * 10);
        }
        return results;
      })(), {
        color: vecColor
      }) + " = " + _this.texVector((function() {
        var j, len1, results;
        results = [];
        for (j = 0, len1 = vout.length; j < len1; j++) {
          x = vout[j];
          results.push(x * 10);
        }
        return results;
      })(), {
        color: vecColor.darken(.1)
      });
      return katex.render(str, multElt);
    };
  })(this);
  params = {
    Multiply: controller.step,
    "Un-multiply": controller.unStep,
    "Test vector": urlParams.get('vec', 'bool', true),
    "Show path": urlParams.get('path', 'bool', true)
  };
  gui = new dat.GUI;
  gui.add(params, "Multiply");
  gui.add(params, "Un-multiply");
  view = controller.viewBase;
  viewT = controller.view;
  this.labeledVectors(view, {
    vectors: [vectorIn, vectorOut],
    colors: [vecColor, vecColor.darken(.1)],
    labels: ['x', matName + 'x'],
    live: true,
    zeroPoints: false,
    zeroThreshold: 0.3,
    vectorOpts: {
      zIndex: 4
    },
    labelOpts: {
      zIndex: 5
    },
    zeroOpts: {
      zIndex: 5
    }
  });
  if (size === 2) {
    snap = function() {};
  } else if (size === 3) {
    subspace = this.subspace({
      vectors: [v1, v2]
    });
    snapped = new THREE.Vector3();
    diff = new THREE.Vector3();
    snap = function(vec) {
      subspace.project(vec, snapped);
      diff.copy(vec).sub(snapped);
      if (diff.lengthSq() <= 0.01) {
        return vec.copy(snapped);
      }
    };
  }
  drag = this.draggable(view, {
    points: [vectorIn],
    onDrag: snap,
    postDrag: function() {
      computeOut();
      return computePath();
    }
  });
  computeOut = function() {
    if (!params["Test vector"]) {
      return;
    }
    vectorOut[0] = vectorIn[0], vectorOut[1] = vectorIn[1], vectorOut[2] = vectorIn[2];
    controller.matrixOrigCoords.applyToVector3Array(vectorOut);
    return updateCaption();
  };
  toggleVector = (function(_this) {
    return function(val) {
      _this.mathbox.select('.labeled').set('visible', val);
      drag.enabled = params["Test vector"] || params["Show path"];
      if (val) {
        computeOut();
        return multElt.classList.remove("hidden");
      } else {
        return multElt.classList.add("hidden");
      }
    };
  })(this);
  gui.add(params, "Test vector").onFinishChange(toggleVector);
  toggleVector(params["Test vector"]);
  path = (function() {
    var j, results;
    results = [];
    for (j = 0; j <= 100; j++) {
      results.push([0, 0, 0]);
    }
    return results;
  })();
  computePath = (function(_this) {
    return function() {
      var vec;
      if (!params["Show path"]) {
        return;
      }
      vec = vectorIn.slice();
      controller.coordMatInv.applyToVector3Array(vec);
      return controller.current.makePath(vec, path);
    };
  })(this);
  viewT.array({
    channels: 3,
    width: path.length,
    live: true,
    data: path
  });
  viewT.line({
    classes: ["test-path"],
    color: new Color("orange").arr(),
    width: 5,
    opacity: 1,
    zBias: 0,
    zIndex: 4
  });
  togglePath = (function(_this) {
    return function(val) {
      if (val) {
        computePath();
      }
      _this.mathbox.select('.test-path').set('visible', val);
      return drag.enabled = params["Test vector"] || params["Show path"];
    };
  })(this);
  gui.add(params, "Show path").onFinishChange(togglePath);
  togglePath(params["Show path"]);
  if (controller.flow) {
    return controller.start(55);
  }
});


        });
    </script>
</body>
</html>

