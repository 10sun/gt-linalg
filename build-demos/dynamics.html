<!DOCTYPE html> <!-- -*- html -*- -->
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="initial-scale=1, maximum-scale=1">
  <title>Dynamics of a 2x2 matrix</title>
  <link rel="shortcut icon" href="img/gatech.gif"/>

  
      <link rel="stylesheet" href="css/demo.css?vers=2759ff">
  

  <style>
      

html, body {
    margin:           0;
    height:           100%;
    background-color: white;
    overflow-x:       hidden;
}
#mathbox {
    width:       100%;
    height:      100%;
}
.espace-1 {
    color: var(--palette-green);
}
.espace-2 {
    color: var(--palette-violet);
}
.overlay-text {
    z-index: 1;
}
#mult-here.hidden {
    display: none;
}

  </style>

</head>
<body>
    

<div id="mathbox">
</div>


    
    
        <script src="js/demo.js?vers=39ead6"></script>
    
    <script src="js/dynamics.js?vers=b128f8"></script>


    <script type="text/javascript">
        "use strict";
        DomReady.ready(function() {

        // Generated by CoffeeScript 1.12.6
var Imλ, Reλ, a, almostZero, axisColors, b, basis1, basis2, c, d, determinant, discriminant, duration, eigenStr, i, len, matName, matrix, normalize, opts, ref, ref1, ref2, ref3, row, swap, testMatrices, trace, type, v, vecColor, δ, λ, λ1, λ2;

matrix = urlParams.get('mat', 'matrix', [[1 / 2, 1 / 2], [-1 / 2, 1 / 2]]);

duration = urlParams.get('duration', 'float', 2.5);

matName = (ref = urlParams.matname) != null ? ref : 'A';

testMatrices = {
  Shear: [[2 / 3, 1 / 3], [-1 / 3, 4 / 3]],
  ScaleOutShear: [[5 / 3, 1 / 3], [-1 / 3, 7 / 3]],
  ScaleInShear: [[1 / 3, 1 / 6], [-1 / 6, 2 / 3]],
  Circle: [[1 / 3, -1 / 3], [5 / 6, 2 / 3]],
  SpiralIn: [[1 / 3, -1 / 3], [5 / 6, 2 / 3]],
  SpiralOut: [[2 / 3, -2 / 3], [5 / 3, 4 / 3]],
  AttractLine: [[5 / 6, 1 / 6], [1 / 3, 2 / 3]],
  RepelLine: [[4 / 3, -1 / 3], [-2 / 3, 5 / 3]],
  Attract: [[7 / 18, -1 / 18], [-1 / 9, 4 / 9]],
  Repel: [[8 / 3, 1 / 3], [2 / 3, 7 / 3]],
  Hyperbolas: [[8 / 9, -5 / 9], [-10 / 9, 13 / 9]]
};

ref1 = testMatrices.Circle;
for (i = 0, len = ref1.length; i < len; i++) {
  row = ref1[i];
  row[0] *= Math.sqrt(2);
  row[1] *= Math.sqrt(2);
}

if (urlParams.testmat != null) {
  matrix = testMatrices[urlParams.testmat];
}

(ref2 = matrix[0], a = ref2[0], b = ref2[1]), (ref3 = matrix[1], c = ref3[0], d = ref3[1]);

trace = a + d;

determinant = a * d - b * c;

discriminant = trace * trace - 4 * determinant;

basis1 = [];

basis2 = [];

type = null;

opts = {};

axisColors = [new Color("green").arr(1), new Color("violet").arr(1)];

eigenStr = '';

almostZero = function(x) {
  return Math.abs(x) < 1e-5;
};

normalize = function(b) {
  var n;
  n = Math.sqrt(b[0] * b[0] + b[1] * b[1]);
  return [b[0] / n, b[1] / n];
};

if (almostZero(determinant)) {
  throw "Can't handle non-invertible matrix";
}

if (almostZero(discriminant)) {
  λ = trace / 2;
  if (λ < 0) {
    throw "Can't handle negative real eigenvalues";
  }
  if (almostZero(b) && almostZero(c)) {
    basis1 = [1, 0];
    basis2 = [0, 1];
    axisColors[1] = axisColors[0];
    eigenStr = "<p>The whole plane is the <span class=\"espace-1\">" + ((λ.toFixed(2)) + "-eigenspace.</span></p>");
    type = λ > 1 ? dynamics.Repel : dynamics.Attract;
    opts = {
      λ1: λ,
      λ2: λ
    };
  } else {
    if (almostZero(b)) {
      basis1 = normalize([b, λ - a]);
    } else {
      basis1 = normalize([λ - d, c]);
    }
    basis2 = [basis1[1], -basis1[0]];
    axisColors[1] = [0.5, 0.5, 0.5, 0.3];
    eigenStr = "<p>This is the <span class=\"espace-1\">" + ((λ.toFixed(2)) + "-eigenspace.</span></p>");
    v = [(a - λ) * basis2[0] + b * basis2[1], c * basis2[0] + (d - λ) * basis2[1]];
    if (almostZero(basis1[0])) {
      opts.translate = v[1] / (λ * basis1[1]);
    } else {
      opts.translate = v[0] / (λ * basis1[0]);
    }
    if (almostZero(λ - 1)) {
      type = dynamics.Shear;
    } else {
      if (λ > 1) {
        type = dynamics.ScaleOutShear;
      } else {
        type = dynamics.ScaleInShear;
      }
      opts.scale = λ;
    }
  }
} else if (discriminant < 0) {
  Reλ = trace / 2;
  Imλ = Math.sqrt(-discriminant) / 2;
  basis1 = [b / Imλ, (Reλ - a) / Imλ];
  basis2 = [0, 1];
  axisColors = [[0.5, 0.5, 0.5, 0.3], [0.5, 0.5, 0.5, 0.3]];
  eigenStr = '<p>This matrix has no real eigenvectors.</p>';
  opts = {
    θ: Math.atan2(-Imλ, Reλ),
    scale: Math.sqrt(determinant),
    dist: 'cont'
  };
  if (almostZero(opts.scale - 1)) {
    type = dynamics.Circle;
  } else {
    if (opts.scale > 1) {
      type = dynamics.SpiralOut;
    } else {
      type = dynamics.SpiralIn;
    }
  }
} else if (discriminant > 0) {
  δ = Math.sqrt(discriminant);
  λ1 = (trace - δ) / 2;
  λ2 = (trace + δ) / 2;
  if (almostZero(b)) {
    if (almostZero(c)) {
      if (almostZero(a - λ1)) {
        basis1 = [1, 0];
        basis2 = [0, 1];
      } else {
        basis2 = [1, 0];
        basis1 = [0, 1];
      }
    } else {
      basis1 = normalize([λ1 - d, c]);
      basis2 = normalize([λ2 - d, c]);
    }
  } else {
    basis1 = normalize([b, λ1 - a]);
    basis2 = normalize([b, λ2 - a]);
  }
  if (λ1 < 0 || λ2 < 0) {
    throw "Can't handle negative real eigenvalues";
  }
  opts = {
    λ1: λ1,
    λ2: λ2
  };
  swap = function() {
    var ref4, ref5;
    ref4 = [opts.λ1, opts.λ2], opts.λ2 = ref4[0], opts.λ1 = ref4[1];
    return ref5 = [basis1, basis2], basis2 = ref5[0], basis1 = ref5[1], ref5;
  };
  if (almostZero(λ1 - 1)) {
    type = dynamics.RepelLine;
  } else if (almostZero(λ2 - 1)) {
    type = dynamics.AttractLine;
    swap();
  } else if (λ1 < 1 && λ2 < 1) {
    type = dynamics.Attract;
    swap();
  } else if (λ1 < 1 && λ2 > 1) {
    type = dynamics.Hyperbolas;
  } else if (λ1 > 1 && λ2 > 1) {
    type = dynamics.Repel;
  }
  eigenStr = "<p>This is the <span class=\"espace-1\">" + ((opts.λ1.toFixed(2)) + "-eigenspace.</span><br>") + "This is the <span class=\"espace-2\">" + ((opts.λ2.toFixed(2)) + "-eigenspace.</span></p>");
}

vecColor = new Color("red");

new Demo2D({
  mathbox: {
    element: document.getElementById("mathbox"),
    size: {
      aspect: 1
    }
  },
  vertical: 1
}, function() {
  var computeOut, controller, drag, gui, matElt, multElt, params, str, toggleVector, updateCaption, vectorIn, vectorOut, view;
  window.controller = controller = new dynamics.Controller(this.mathbox, {
    continuous: false,
    axisOpts: {
      width: 3,
      opacity: 1.0
    },
    axisColors: axisColors,
    duration: duration
  });
  controller.installCoords([basis1[0], basis2[0], basis1[1], basis2[1]]);
  controller.install(type, opts);
  console.log("Type: ", controller.current.descr());
  console.log("Opts: ", opts);
  vectorIn = [.5, 0];
  vectorOut = [0, 0];
  str = '<p><span id="mat-here"></span>' + '<span id="mult-here"></span></p>';
  str += eigenStr;
  this.caption(str);
  matElt = document.getElementById('mat-here');
  multElt = document.getElementById('mult-here');
  str = (matName + " = ") + this.texMatrix(matrix);
  katex.render(str, matElt);
  updateCaption = (function(_this) {
    return function() {
      var x;
      str = '\\qquad ' + matName + _this.texVector((function() {
        var j, len1, results;
        results = [];
        for (j = 0, len1 = vectorIn.length; j < len1; j++) {
          x = vectorIn[j];
          results.push(x * 10);
        }
        return results;
      })(), {
        color: vecColor
      }) + " = " + _this.texVector((function() {
        var j, len1, results;
        results = [];
        for (j = 0, len1 = vectorOut.length; j < len1; j++) {
          x = vectorOut[j];
          results.push(x * 10);
        }
        return results;
      })(), {
        color: vecColor.darken(.1)
      });
      return katex.render(str, multElt);
    };
  })(this);
  view = controller.view0;
  this.labeledVectors(view, {
    vectors: [vectorIn, vectorOut],
    colors: [vecColor, vecColor.darken(.1)],
    labels: ['x', matName + 'x'],
    live: true,
    zeroPoints: false,
    zeroThreshold: 0.3,
    vectorOpts: {
      zIndex: 4
    },
    labelOpts: {
      zIndex: 5
    },
    zeroOpts: {
      zIndex: 5
    }
  });
  computeOut = function() {
    var m;
    m = matrix;
    v = vectorIn;
    vectorOut[0] = m[0][0] * v[0] + m[0][1] * v[1];
    vectorOut[1] = m[1][0] * v[0] + m[1][1] * v[1];
    return updateCaption();
  };
  computeOut();
  toggleVector = (function(_this) {
    return function(val) {
      _this.mathbox.select('.labeled').set('visible', val);
      drag.enabled = val;
      if (val) {
        return multElt.classList.remove("hidden");
      } else {
        return multElt.classList.add("hidden");
      }
    };
  })(this);
  drag = this.draggable(view, {
    points: [vectorIn],
    postDrag: computeOut
  });
  params = {
    Multiply: controller.step,
    "Un-multiply": controller.unStep,
    "Test Vector": urlParams.get('vec', 'bool', true)
  };
  gui = new dat.GUI;
  gui.add(params, "Multiply");
  gui.add(params, "Un-multiply");
  gui.add(params, "Test Vector").onFinishChange(toggleVector);
  return toggleVector(params["Test Vector"]);
});


        });
    </script>
</body>
</html>

